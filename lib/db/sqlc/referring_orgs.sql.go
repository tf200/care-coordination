// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: referring_orgs.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createReferringOrg = `-- name: CreateReferringOrg :exec
INSERT INTO referring_orgs (
    id,
    name,
    contact_person,
    phone_number,
    email
) VALUES (
    $1, $2, $3, $4, $5
)
`

type CreateReferringOrgParams struct {
	ID            string `json:"id"`
	Name          string `json:"name"`
	ContactPerson string `json:"contact_person"`
	PhoneNumber   string `json:"phone_number"`
	Email         string `json:"email"`
}

func (q *Queries) CreateReferringOrg(ctx context.Context, arg CreateReferringOrgParams) error {
	_, err := q.db.Exec(ctx, createReferringOrg,
		arg.ID,
		arg.Name,
		arg.ContactPerson,
		arg.PhoneNumber,
		arg.Email,
	)
	return err
}

const deleteReferringOrg = `-- name: DeleteReferringOrg :exec
DELETE FROM referring_orgs
WHERE id = $1
`

func (q *Queries) DeleteReferringOrg(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteReferringOrg, id)
	return err
}

const getReferringOrgByID = `-- name: GetReferringOrgByID :one
SELECT
    id,
    name,
    contact_person,
    phone_number,
    email,
    created_at,
    updated_at
FROM referring_orgs
WHERE id = $1
`

func (q *Queries) GetReferringOrgByID(ctx context.Context, id string) (ReferringOrg, error) {
	row := q.db.QueryRow(ctx, getReferringOrgByID, id)
	var i ReferringOrg
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.ContactPerson,
		&i.PhoneNumber,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listReferringOrgs = `-- name: ListReferringOrgs :many
SELECT
    id,
    name,
    contact_person,
    phone_number,
    email,
    created_at,
    updated_at,
    COUNT(id) OVER () AS total_count
FROM referring_orgs
WHERE
    (
        -- If search term is NULL or empty, ignore filters
        $3::text IS NULL OR $3::text = '' OR
        -- Search by Org Name
        name ILIKE '%' || $3 || '%' OR
        -- Search by Contact Person
        contact_person ILIKE '%' || $3 || '%' OR
        -- Search by Email
        email ILIKE '%' || $3 || '%'
    )
ORDER BY name
LIMIT $1 OFFSET $2
`

type ListReferringOrgsParams struct {
	Limit  int32   `json:"limit"`
	Offset int32   `json:"offset"`
	Search *string `json:"search"`
}

type ListReferringOrgsRow struct {
	ID            string             `json:"id"`
	Name          string             `json:"name"`
	ContactPerson string             `json:"contact_person"`
	PhoneNumber   string             `json:"phone_number"`
	Email         string             `json:"email"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	TotalCount    int64              `json:"total_count"`
}

func (q *Queries) ListReferringOrgs(ctx context.Context, arg ListReferringOrgsParams) ([]ListReferringOrgsRow, error) {
	rows, err := q.db.Query(ctx, listReferringOrgs, arg.Limit, arg.Offset, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReferringOrgsRow{}
	for rows.Next() {
		var i ListReferringOrgsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ContactPerson,
			&i.PhoneNumber,
			&i.Email,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReferringOrgsWithCounts = `-- name: ListReferringOrgsWithCounts :many
SELECT
    ro.id,
    ro.name,
    ro.contact_person,
    ro.phone_number,
    ro.email,
    ro.created_at,
    ro.updated_at,
    COUNT(CASE WHEN c.status = 'in_care' THEN 1 END)::bigint AS in_care_count,
    COUNT(CASE WHEN c.status = 'waiting_list' THEN 1 END)::bigint AS waiting_list_count,
    COUNT(CASE WHEN c.status = 'discharged' THEN 1 END)::bigint AS discharged_count,
    COUNT(ro.id) OVER () AS total_count
FROM referring_orgs ro
LEFT JOIN clients c ON c.referring_org_id = ro.id
WHERE
    (
        -- If search term is NULL or empty, ignore filters
        $3::text IS NULL OR $3::text = '' OR
        -- Search by Org Name
        ro.name ILIKE '%' || $3 || '%' OR
        -- Search by Contact Person
        ro.contact_person ILIKE '%' || $3 || '%' OR
        -- Search by Email
        ro.email ILIKE '%' || $3 || '%'
    )
GROUP BY ro.id, ro.name, ro.contact_person, ro.phone_number, ro.email, ro.created_at, ro.updated_at
ORDER BY ro.name
LIMIT $1 OFFSET $2
`

type ListReferringOrgsWithCountsParams struct {
	Limit  int32   `json:"limit"`
	Offset int32   `json:"offset"`
	Search *string `json:"search"`
}

type ListReferringOrgsWithCountsRow struct {
	ID               string             `json:"id"`
	Name             string             `json:"name"`
	ContactPerson    string             `json:"contact_person"`
	PhoneNumber      string             `json:"phone_number"`
	Email            string             `json:"email"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	InCareCount      int64              `json:"in_care_count"`
	WaitingListCount int64              `json:"waiting_list_count"`
	DischargedCount  int64              `json:"discharged_count"`
	TotalCount       int64              `json:"total_count"`
}

func (q *Queries) ListReferringOrgsWithCounts(ctx context.Context, arg ListReferringOrgsWithCountsParams) ([]ListReferringOrgsWithCountsRow, error) {
	rows, err := q.db.Query(ctx, listReferringOrgsWithCounts, arg.Limit, arg.Offset, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReferringOrgsWithCountsRow{}
	for rows.Next() {
		var i ListReferringOrgsWithCountsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ContactPerson,
			&i.PhoneNumber,
			&i.Email,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.InCareCount,
			&i.WaitingListCount,
			&i.DischargedCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateReferringOrg = `-- name: UpdateReferringOrg :exec
UPDATE referring_orgs
SET
    name = COALESCE($2, name),
    contact_person = COALESCE($3, contact_person),
    phone_number = COALESCE($4, phone_number),
    email = COALESCE($5, email),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateReferringOrgParams struct {
	ID            string  `json:"id"`
	Name          *string `json:"name"`
	ContactPerson *string `json:"contact_person"`
	PhoneNumber   *string `json:"phone_number"`
	Email         *string `json:"email"`
}

func (q *Queries) UpdateReferringOrg(ctx context.Context, arg UpdateReferringOrgParams) error {
	_, err := q.db.Exec(ctx, updateReferringOrg,
		arg.ID,
		arg.Name,
		arg.ContactPerson,
		arg.PhoneNumber,
		arg.Email,
	)
	return err
}
