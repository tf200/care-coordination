// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: clients.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createClient = `-- name: CreateClient :one

INSERT INTO clients (
    id,
    first_name,
    last_name,
    bsn,
    date_of_birth,
    phone_number,
    gender,
    registration_form_id,
    intake_form_id,
    care_type,
    referring_org_id,
    waiting_list_priority,
    status,
    assigned_location_id,
    coordinator_id,
    family_situation,
    limitations,
    focus_areas,
    notes,
    evaluation_interval_weeks
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20
)
RETURNING id, first_name, last_name, bsn, date_of_birth, phone_number, gender, registration_form_id, intake_form_id, care_type, referring_org_id, status, assigned_location_id, coordinator_id, family_situation, limitations, focus_areas, notes, evaluation_interval_weeks, next_evaluation_date, created_at, updated_at
`

type CreateClientParams struct {
	ID                      string                  `json:"id"`
	FirstName               string                  `json:"first_name"`
	LastName                string                  `json:"last_name"`
	Bsn                     string                  `json:"bsn"`
	DateOfBirth             pgtype.Date             `json:"date_of_birth"`
	PhoneNumber             *string                 `json:"phone_number"`
	Gender                  GenderEnum              `json:"gender"`
	RegistrationFormID      string                  `json:"registration_form_id"`
	IntakeFormID            string                  `json:"intake_form_id"`
	CareType                CareTypeEnum            `json:"care_type"`
	ReferringOrgID          *string                 `json:"referring_org_id"`
	WaitingListPriority     WaitingListPriorityEnum `json:"waiting_list_priority"`
	Status                  ClientStatusEnum        `json:"status"`
	AssignedLocationID      string                  `json:"assigned_location_id"`
	CoordinatorID           string                  `json:"coordinator_id"`
	FamilySituation         *string                 `json:"family_situation"`
	Limitations             *string                 `json:"limitations"`
	FocusAreas              *string                 `json:"focus_areas"`
	Notes                   *string                 `json:"notes"`
	EvaluationIntervalWeeks *int32                  `json:"evaluation_interval_weeks"`
}

type CreateClientRow struct {
	ID                      string           `json:"id"`
	FirstName               string           `json:"first_name"`
	LastName                string           `json:"last_name"`
	Bsn                     string           `json:"bsn"`
	DateOfBirth             pgtype.Date      `json:"date_of_birth"`
	PhoneNumber             *string          `json:"phone_number"`
	Gender                  GenderEnum       `json:"gender"`
	RegistrationFormID      string           `json:"registration_form_id"`
	IntakeFormID            string           `json:"intake_form_id"`
	CareType                CareTypeEnum     `json:"care_type"`
	ReferringOrgID          *string          `json:"referring_org_id"`
	Status                  ClientStatusEnum `json:"status"`
	AssignedLocationID      string           `json:"assigned_location_id"`
	CoordinatorID           string           `json:"coordinator_id"`
	FamilySituation         *string          `json:"family_situation"`
	Limitations             *string          `json:"limitations"`
	FocusAreas              *string          `json:"focus_areas"`
	Notes                   *string          `json:"notes"`
	EvaluationIntervalWeeks *int32           `json:"evaluation_interval_weeks"`
	NextEvaluationDate      pgtype.Date      `json:"next_evaluation_date"`
	CreatedAt               pgtype.Timestamp `json:"created_at"`
	UpdatedAt               pgtype.Timestamp `json:"updated_at"`
}

// ============================================================
// Clients
// ============================================================
func (q *Queries) CreateClient(ctx context.Context, arg CreateClientParams) (CreateClientRow, error) {
	row := q.db.QueryRow(ctx, createClient,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Bsn,
		arg.DateOfBirth,
		arg.PhoneNumber,
		arg.Gender,
		arg.RegistrationFormID,
		arg.IntakeFormID,
		arg.CareType,
		arg.ReferringOrgID,
		arg.WaitingListPriority,
		arg.Status,
		arg.AssignedLocationID,
		arg.CoordinatorID,
		arg.FamilySituation,
		arg.Limitations,
		arg.FocusAreas,
		arg.Notes,
		arg.EvaluationIntervalWeeks,
	)
	var i CreateClientRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Bsn,
		&i.DateOfBirth,
		&i.PhoneNumber,
		&i.Gender,
		&i.RegistrationFormID,
		&i.IntakeFormID,
		&i.CareType,
		&i.ReferringOrgID,
		&i.Status,
		&i.AssignedLocationID,
		&i.CoordinatorID,
		&i.FamilySituation,
		&i.Limitations,
		&i.FocusAreas,
		&i.Notes,
		&i.EvaluationIntervalWeeks,
		&i.NextEvaluationDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getClientByID = `-- name: GetClientByID :one
SELECT id, first_name, last_name, bsn, date_of_birth, phone_number, gender, registration_form_id, intake_form_id, care_type, ambulatory_weekly_hours, referring_org_id, status, waiting_list_priority, care_start_date, care_end_date, discharge_date, closing_report, evaluation_report, reason_for_discharge, discharge_attachment_ids, discharge_status, assigned_location_id, coordinator_id, family_situation, limitations, focus_areas, notes, evaluation_interval_weeks, next_evaluation_date, created_at, updated_at FROM clients WHERE id = $1
`

func (q *Queries) GetClientByID(ctx context.Context, id string) (Client, error) {
	row := q.db.QueryRow(ctx, getClientByID, id)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Bsn,
		&i.DateOfBirth,
		&i.PhoneNumber,
		&i.Gender,
		&i.RegistrationFormID,
		&i.IntakeFormID,
		&i.CareType,
		&i.AmbulatoryWeeklyHours,
		&i.ReferringOrgID,
		&i.Status,
		&i.WaitingListPriority,
		&i.CareStartDate,
		&i.CareEndDate,
		&i.DischargeDate,
		&i.ClosingReport,
		&i.EvaluationReport,
		&i.ReasonForDischarge,
		&i.DischargeAttachmentIds,
		&i.DischargeStatus,
		&i.AssignedLocationID,
		&i.CoordinatorID,
		&i.FamilySituation,
		&i.Limitations,
		&i.FocusAreas,
		&i.Notes,
		&i.EvaluationIntervalWeeks,
		&i.NextEvaluationDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDischargeStats = `-- name: GetDischargeStats :one
SELECT 
    COUNT(*) as total_count,
    COUNT(*) FILTER (WHERE reason_for_discharge IS NOT NULL AND reason_for_discharge = 'treatment_completed') as completed_discharges,
    COUNT(*) FILTER (WHERE reason_for_discharge IS NOT NULL AND reason_for_discharge != 'treatment_completed') as premature_discharges,
    CASE 
        WHEN COUNT(*) > 0 THEN 
            ROUND((COUNT(*) FILTER (WHERE discharge_status = 'completed')::DECIMAL / COUNT(*)::DECIMAL) * 100, 2)
        ELSE 0
    END as discharge_completion_rate,
    COALESCE(AVG(discharge_date - care_start_date) FILTER (WHERE discharge_date IS NOT NULL AND care_start_date IS NOT NULL), 0)::DOUBLE PRECISION as avg_days_in_care
FROM clients
WHERE discharge_status IS NOT NULL
`

type GetDischargeStatsRow struct {
	TotalCount              int64   `json:"total_count"`
	CompletedDischarges     int64   `json:"completed_discharges"`
	PrematureDischarges     int64   `json:"premature_discharges"`
	DischargeCompletionRate int32   `json:"discharge_completion_rate"`
	AvgDaysInCare           float64 `json:"avg_days_in_care"`
}

func (q *Queries) GetDischargeStats(ctx context.Context) (GetDischargeStatsRow, error) {
	row := q.db.QueryRow(ctx, getDischargeStats)
	var i GetDischargeStatsRow
	err := row.Scan(
		&i.TotalCount,
		&i.CompletedDischarges,
		&i.PrematureDischarges,
		&i.DischargeCompletionRate,
		&i.AvgDaysInCare,
	)
	return i, err
}

const getInCareStats = `-- name: GetInCareStats :one
SELECT 
    COUNT(*) as total_count,
    COALESCE(AVG(EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - care_start_date)) / 86400), 0) as avg_days_in_care,
    COUNT(*) FILTER (WHERE care_type = 'protected_living') as protected_living_count,
    COUNT(*) FILTER (WHERE care_type = 'semi_independent_living') as semi_independent_living_count,
    COUNT(*) FILTER (WHERE care_type = 'independent_assisted_living') as independent_assisted_living_count,
    COUNT(*) FILTER (WHERE care_type = 'ambulatory_care') as ambulatory_care_count
FROM clients
WHERE status = 'in_care'
`

type GetInCareStatsRow struct {
	TotalCount                     int64       `json:"total_count"`
	AvgDaysInCare                  interface{} `json:"avg_days_in_care"`
	ProtectedLivingCount           int64       `json:"protected_living_count"`
	SemiIndependentLivingCount     int64       `json:"semi_independent_living_count"`
	IndependentAssistedLivingCount int64       `json:"independent_assisted_living_count"`
	AmbulatoryCareCount            int64       `json:"ambulatory_care_count"`
}

func (q *Queries) GetInCareStats(ctx context.Context) (GetInCareStatsRow, error) {
	row := q.db.QueryRow(ctx, getInCareStats)
	var i GetInCareStatsRow
	err := row.Scan(
		&i.TotalCount,
		&i.AvgDaysInCare,
		&i.ProtectedLivingCount,
		&i.SemiIndependentLivingCount,
		&i.IndependentAssistedLivingCount,
		&i.AmbulatoryCareCount,
	)
	return i, err
}

const getWaitlistStats = `-- name: GetWaitlistStats :one
SELECT 
    COUNT(*) as total_count,
    COALESCE(AVG(EXTRACT(EPOCH FROM (CURRENT_TIMESTAMP - created_at)) / 86400), 0) as avg_days_waiting,
    COUNT(*) FILTER (WHERE waiting_list_priority = 'high') as high_priority_count,
    COUNT(*) FILTER (WHERE waiting_list_priority = 'low') as low_priority_count,
    COUNT(*) FILTER (WHERE waiting_list_priority = 'normal') as normal_priority_count
FROM clients
WHERE status = 'waiting_list'
`

type GetWaitlistStatsRow struct {
	TotalCount          int64       `json:"total_count"`
	AvgDaysWaiting      interface{} `json:"avg_days_waiting"`
	HighPriorityCount   int64       `json:"high_priority_count"`
	LowPriorityCount    int64       `json:"low_priority_count"`
	NormalPriorityCount int64       `json:"normal_priority_count"`
}

func (q *Queries) GetWaitlistStats(ctx context.Context) (GetWaitlistStatsRow, error) {
	row := q.db.QueryRow(ctx, getWaitlistStats)
	var i GetWaitlistStatsRow
	err := row.Scan(
		&i.TotalCount,
		&i.AvgDaysWaiting,
		&i.HighPriorityCount,
		&i.LowPriorityCount,
		&i.NormalPriorityCount,
	)
	return i, err
}

const listDischargedClients = `-- name: ListDischargedClients :many
SELECT
    c.id,
    c.first_name,
    c.last_name,
    c.bsn,
    c.date_of_birth,
    c.phone_number,
    c.gender,
    c.care_type,
    c.care_start_date,
    c.discharge_date,
    c.reason_for_discharge,
    c.discharge_status,
    c.closing_report,
    c.evaluation_report,
    c.created_at,
    l.id AS location_id,
    l.name AS location_name,
    e.id AS coordinator_id,
    e.first_name AS coordinator_first_name,
    e.last_name AS coordinator_last_name,
    ro.name AS referring_org_name,
    COUNT(*) OVER() AS total_count
FROM clients c
JOIN locations l ON c.assigned_location_id = l.id
JOIN employees e ON c.coordinator_id = e.id
LEFT JOIN referring_orgs ro ON c.referring_org_id = ro.id
WHERE c.discharge_status IS NOT NULL
    AND ($3::text IS NULL OR
         LOWER(c.first_name) LIKE LOWER('%' || $3::text || '%') OR
         LOWER(c.last_name) LIKE LOWER('%' || $3::text || '%') OR
         LOWER(c.first_name || ' ' || c.last_name) LIKE LOWER('%' || $3::text || '%'))
    AND ($4::discharge_status_enum IS NULL OR
         c.discharge_status = $4::discharge_status_enum)
ORDER BY c.discharge_date DESC
LIMIT $1 OFFSET $2
`

type ListDischargedClientsParams struct {
	Limit           int32                   `json:"limit"`
	Offset          int32                   `json:"offset"`
	Search          *string                 `json:"search"`
	DischargeStatus NullDischargeStatusEnum `json:"discharge_status"`
}

type ListDischargedClientsRow struct {
	ID                   string                  `json:"id"`
	FirstName            string                  `json:"first_name"`
	LastName             string                  `json:"last_name"`
	Bsn                  string                  `json:"bsn"`
	DateOfBirth          pgtype.Date             `json:"date_of_birth"`
	PhoneNumber          *string                 `json:"phone_number"`
	Gender               GenderEnum              `json:"gender"`
	CareType             CareTypeEnum            `json:"care_type"`
	CareStartDate        pgtype.Date             `json:"care_start_date"`
	DischargeDate        pgtype.Date             `json:"discharge_date"`
	ReasonForDischarge   NullDischargeReasonEnum `json:"reason_for_discharge"`
	DischargeStatus      NullDischargeStatusEnum `json:"discharge_status"`
	ClosingReport        *string                 `json:"closing_report"`
	EvaluationReport     *string                 `json:"evaluation_report"`
	CreatedAt            pgtype.Timestamp        `json:"created_at"`
	LocationID           string                  `json:"location_id"`
	LocationName         string                  `json:"location_name"`
	CoordinatorID        string                  `json:"coordinator_id"`
	CoordinatorFirstName string                  `json:"coordinator_first_name"`
	CoordinatorLastName  string                  `json:"coordinator_last_name"`
	ReferringOrgName     *string                 `json:"referring_org_name"`
	TotalCount           int64                   `json:"total_count"`
}

func (q *Queries) ListDischargedClients(ctx context.Context, arg ListDischargedClientsParams) ([]ListDischargedClientsRow, error) {
	rows, err := q.db.Query(ctx, listDischargedClients,
		arg.Limit,
		arg.Offset,
		arg.Search,
		arg.DischargeStatus,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDischargedClientsRow{}
	for rows.Next() {
		var i ListDischargedClientsRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Bsn,
			&i.DateOfBirth,
			&i.PhoneNumber,
			&i.Gender,
			&i.CareType,
			&i.CareStartDate,
			&i.DischargeDate,
			&i.ReasonForDischarge,
			&i.DischargeStatus,
			&i.ClosingReport,
			&i.EvaluationReport,
			&i.CreatedAt,
			&i.LocationID,
			&i.LocationName,
			&i.CoordinatorID,
			&i.CoordinatorFirstName,
			&i.CoordinatorLastName,
			&i.ReferringOrgName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInCareClients = `-- name: ListInCareClients :many
SELECT
    c.id,
    c.first_name,
    c.last_name,
    c.bsn,
    c.date_of_birth,
    c.phone_number,
    c.gender,
    c.care_type,
    c.care_start_date,
    c.care_end_date,
    c.ambulatory_weekly_hours,
    c.created_at,
    l.id AS location_id,
    l.name AS location_name,
    e.id AS coordinator_id,
    e.first_name AS coordinator_first_name,
    e.last_name AS coordinator_last_name,
    ro.name AS referring_org_name,
    COUNT(*) OVER() AS total_count
FROM clients c
JOIN locations l ON c.assigned_location_id = l.id
JOIN employees e ON c.coordinator_id = e.id
LEFT JOIN referring_orgs ro ON c.referring_org_id = ro.id
WHERE c.status = 'in_care'
    AND ($3::text IS NULL OR
         LOWER(c.first_name) LIKE LOWER('%' || $3::text || '%') OR
         LOWER(c.last_name) LIKE LOWER('%' || $3::text || '%') OR
         LOWER(c.first_name || ' ' || c.last_name) LIKE LOWER('%' || $3::text || '%'))
    AND ($4::care_type_enum IS NULL OR
         c.care_type = $4::care_type_enum)
ORDER BY c.care_start_date DESC
LIMIT $1 OFFSET $2
`

type ListInCareClientsParams struct {
	Limit    int32            `json:"limit"`
	Offset   int32            `json:"offset"`
	Search   *string          `json:"search"`
	CareType NullCareTypeEnum `json:"care_type"`
}

type ListInCareClientsRow struct {
	ID                    string           `json:"id"`
	FirstName             string           `json:"first_name"`
	LastName              string           `json:"last_name"`
	Bsn                   string           `json:"bsn"`
	DateOfBirth           pgtype.Date      `json:"date_of_birth"`
	PhoneNumber           *string          `json:"phone_number"`
	Gender                GenderEnum       `json:"gender"`
	CareType              CareTypeEnum     `json:"care_type"`
	CareStartDate         pgtype.Date      `json:"care_start_date"`
	CareEndDate           pgtype.Date      `json:"care_end_date"`
	AmbulatoryWeeklyHours *int32           `json:"ambulatory_weekly_hours"`
	CreatedAt             pgtype.Timestamp `json:"created_at"`
	LocationID            string           `json:"location_id"`
	LocationName          string           `json:"location_name"`
	CoordinatorID         string           `json:"coordinator_id"`
	CoordinatorFirstName  string           `json:"coordinator_first_name"`
	CoordinatorLastName   string           `json:"coordinator_last_name"`
	ReferringOrgName      *string          `json:"referring_org_name"`
	TotalCount            int64            `json:"total_count"`
}

func (q *Queries) ListInCareClients(ctx context.Context, arg ListInCareClientsParams) ([]ListInCareClientsRow, error) {
	rows, err := q.db.Query(ctx, listInCareClients,
		arg.Limit,
		arg.Offset,
		arg.Search,
		arg.CareType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListInCareClientsRow{}
	for rows.Next() {
		var i ListInCareClientsRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Bsn,
			&i.DateOfBirth,
			&i.PhoneNumber,
			&i.Gender,
			&i.CareType,
			&i.CareStartDate,
			&i.CareEndDate,
			&i.AmbulatoryWeeklyHours,
			&i.CreatedAt,
			&i.LocationID,
			&i.LocationName,
			&i.CoordinatorID,
			&i.CoordinatorFirstName,
			&i.CoordinatorLastName,
			&i.ReferringOrgName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWaitingListClients = `-- name: ListWaitingListClients :many
SELECT
    c.id,
    c.first_name,
    c.last_name,
    c.bsn,
    c.date_of_birth,
    c.phone_number,
    c.gender,
    c.care_type,
    c.waiting_list_priority,
    c.focus_areas,
    c.notes,
    c.created_at,
    l.id AS location_id,
    l.name AS location_name,
    e.id AS coordinator_id,
    e.first_name AS coordinator_first_name,
    e.last_name AS coordinator_last_name,
    ro.name AS referring_org_name,
    COUNT(*) OVER() AS total_count
FROM clients c
JOIN locations l ON c.assigned_location_id = l.id
JOIN employees e ON c.coordinator_id = e.id
LEFT JOIN referring_orgs ro ON c.referring_org_id = ro.id
WHERE c.status = 'waiting_list'
    AND ($3::text IS NULL OR
         LOWER(c.first_name) LIKE LOWER('%' || $3::text || '%') OR
         LOWER(c.last_name) LIKE LOWER('%' || $3::text || '%') OR
         LOWER(c.first_name || ' ' || c.last_name) LIKE LOWER('%' || $3::text || '%'))
ORDER BY
    CASE c.waiting_list_priority
        WHEN 'high' THEN 1
        WHEN 'normal' THEN 2
        WHEN 'low' THEN 3
    END,
    c.created_at ASC
LIMIT $1 OFFSET $2
`

type ListWaitingListClientsParams struct {
	Limit  int32   `json:"limit"`
	Offset int32   `json:"offset"`
	Search *string `json:"search"`
}

type ListWaitingListClientsRow struct {
	ID                   string                  `json:"id"`
	FirstName            string                  `json:"first_name"`
	LastName             string                  `json:"last_name"`
	Bsn                  string                  `json:"bsn"`
	DateOfBirth          pgtype.Date             `json:"date_of_birth"`
	PhoneNumber          *string                 `json:"phone_number"`
	Gender               GenderEnum              `json:"gender"`
	CareType             CareTypeEnum            `json:"care_type"`
	WaitingListPriority  WaitingListPriorityEnum `json:"waiting_list_priority"`
	FocusAreas           *string                 `json:"focus_areas"`
	Notes                *string                 `json:"notes"`
	CreatedAt            pgtype.Timestamp        `json:"created_at"`
	LocationID           string                  `json:"location_id"`
	LocationName         string                  `json:"location_name"`
	CoordinatorID        string                  `json:"coordinator_id"`
	CoordinatorFirstName string                  `json:"coordinator_first_name"`
	CoordinatorLastName  string                  `json:"coordinator_last_name"`
	ReferringOrgName     *string                 `json:"referring_org_name"`
	TotalCount           int64                   `json:"total_count"`
}

func (q *Queries) ListWaitingListClients(ctx context.Context, arg ListWaitingListClientsParams) ([]ListWaitingListClientsRow, error) {
	rows, err := q.db.Query(ctx, listWaitingListClients, arg.Limit, arg.Offset, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWaitingListClientsRow{}
	for rows.Next() {
		var i ListWaitingListClientsRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Bsn,
			&i.DateOfBirth,
			&i.PhoneNumber,
			&i.Gender,
			&i.CareType,
			&i.WaitingListPriority,
			&i.FocusAreas,
			&i.Notes,
			&i.CreatedAt,
			&i.LocationID,
			&i.LocationName,
			&i.CoordinatorID,
			&i.CoordinatorFirstName,
			&i.CoordinatorLastName,
			&i.ReferringOrgName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateClient = `-- name: UpdateClient :one
UPDATE clients SET
    first_name = COALESCE($2, first_name),
    last_name = COALESCE($3, last_name),
    bsn = COALESCE($4, bsn),
    date_of_birth = COALESCE($5, date_of_birth),
    phone_number = COALESCE($6, phone_number),
    gender = COALESCE($7::gender_enum, gender),
    registration_form_id = COALESCE($8, registration_form_id),
    intake_form_id = COALESCE($9, intake_form_id),
    care_type = COALESCE($10::care_type_enum, care_type),
    referring_org_id = COALESCE($11, referring_org_id),
    waiting_list_priority = COALESCE($12::waiting_list_priority_enum, waiting_list_priority),
    status = COALESCE($13::client_status_enum, status),
    assigned_location_id = COALESCE($14, assigned_location_id),
    coordinator_id = COALESCE($15, coordinator_id),
    family_situation = COALESCE($16, family_situation),
    limitations = COALESCE($17, limitations),
    focus_areas = COALESCE($18, focus_areas),
    notes = COALESCE($19, notes),
    evaluation_interval_weeks = COALESCE($20, evaluation_interval_weeks),
    next_evaluation_date = COALESCE($21, next_evaluation_date),
    ambulatory_weekly_hours = COALESCE($22, ambulatory_weekly_hours),
    care_start_date = COALESCE($23, care_start_date),
    care_end_date = COALESCE($24, care_end_date),
    discharge_date = COALESCE($25, discharge_date),
    closing_report = COALESCE($26, closing_report),
    evaluation_report = COALESCE($27, evaluation_report),
    reason_for_discharge = COALESCE($28::discharge_reason_enum, reason_for_discharge),
    discharge_attachment_ids = COALESCE($29, discharge_attachment_ids),
    discharge_status = COALESCE($30::discharge_status_enum, discharge_status),
    updated_at = NOW()
WHERE id = $1
RETURNING id
`

type UpdateClientParams struct {
	ID                      string                      `json:"id"`
	FirstName               *string                     `json:"first_name"`
	LastName                *string                     `json:"last_name"`
	Bsn                     *string                     `json:"bsn"`
	DateOfBirth             pgtype.Date                 `json:"date_of_birth"`
	PhoneNumber             *string                     `json:"phone_number"`
	Gender                  NullGenderEnum              `json:"gender"`
	RegistrationFormID      *string                     `json:"registration_form_id"`
	IntakeFormID            *string                     `json:"intake_form_id"`
	CareType                NullCareTypeEnum            `json:"care_type"`
	ReferringOrgID          *string                     `json:"referring_org_id"`
	WaitingListPriority     NullWaitingListPriorityEnum `json:"waiting_list_priority"`
	Status                  NullClientStatusEnum        `json:"status"`
	AssignedLocationID      *string                     `json:"assigned_location_id"`
	CoordinatorID           *string                     `json:"coordinator_id"`
	FamilySituation         *string                     `json:"family_situation"`
	Limitations             *string                     `json:"limitations"`
	FocusAreas              *string                     `json:"focus_areas"`
	Notes                   *string                     `json:"notes"`
	EvaluationIntervalWeeks *int32                      `json:"evaluation_interval_weeks"`
	NextEvaluationDate      pgtype.Date                 `json:"next_evaluation_date"`
	AmbulatoryWeeklyHours   *int32                      `json:"ambulatory_weekly_hours"`
	CareStartDate           pgtype.Date                 `json:"care_start_date"`
	CareEndDate             pgtype.Date                 `json:"care_end_date"`
	DischargeDate           pgtype.Date                 `json:"discharge_date"`
	ClosingReport           *string                     `json:"closing_report"`
	EvaluationReport        *string                     `json:"evaluation_report"`
	ReasonForDischarge      NullDischargeReasonEnum     `json:"reason_for_discharge"`
	DischargeAttachmentIds  []string                    `json:"discharge_attachment_ids"`
	DischargeStatus         NullDischargeStatusEnum     `json:"discharge_status"`
}

func (q *Queries) UpdateClient(ctx context.Context, arg UpdateClientParams) (string, error) {
	row := q.db.QueryRow(ctx, updateClient,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Bsn,
		arg.DateOfBirth,
		arg.PhoneNumber,
		arg.Gender,
		arg.RegistrationFormID,
		arg.IntakeFormID,
		arg.CareType,
		arg.ReferringOrgID,
		arg.WaitingListPriority,
		arg.Status,
		arg.AssignedLocationID,
		arg.CoordinatorID,
		arg.FamilySituation,
		arg.Limitations,
		arg.FocusAreas,
		arg.Notes,
		arg.EvaluationIntervalWeeks,
		arg.NextEvaluationDate,
		arg.AmbulatoryWeeklyHours,
		arg.CareStartDate,
		arg.CareEndDate,
		arg.DischargeDate,
		arg.ClosingReport,
		arg.EvaluationReport,
		arg.ReasonForDischarge,
		arg.DischargeAttachmentIds,
		arg.DischargeStatus,
	)
	var id string
	err := row.Scan(&id)
	return id, err
}

const updateClientByIntakeFormID = `-- name: UpdateClientByIntakeFormID :exec
UPDATE clients SET
    coordinator_id = COALESCE($2, coordinator_id),
    assigned_location_id = COALESCE($3, assigned_location_id),
    family_situation = COALESCE($4, family_situation),
    limitations = COALESCE($5, limitations),
    focus_areas = COALESCE($6, focus_areas),
    notes = COALESCE($7, notes),
    evaluation_interval_weeks = COALESCE($8, evaluation_interval_weeks),
    updated_at = NOW()
WHERE intake_form_id = $1
`

type UpdateClientByIntakeFormIDParams struct {
	IntakeFormID            string  `json:"intake_form_id"`
	CoordinatorID           *string `json:"coordinator_id"`
	AssignedLocationID      *string `json:"assigned_location_id"`
	FamilySituation         *string `json:"family_situation"`
	Limitations             *string `json:"limitations"`
	FocusAreas              *string `json:"focus_areas"`
	Notes                   *string `json:"notes"`
	EvaluationIntervalWeeks *int32  `json:"evaluation_interval_weeks"`
}

func (q *Queries) UpdateClientByIntakeFormID(ctx context.Context, arg UpdateClientByIntakeFormIDParams) error {
	_, err := q.db.Exec(ctx, updateClientByIntakeFormID,
		arg.IntakeFormID,
		arg.CoordinatorID,
		arg.AssignedLocationID,
		arg.FamilySituation,
		arg.Limitations,
		arg.FocusAreas,
		arg.Notes,
		arg.EvaluationIntervalWeeks,
	)
	return err
}

const updateClientByRegistrationFormID = `-- name: UpdateClientByRegistrationFormID :exec
UPDATE clients SET
    first_name = COALESCE($2, first_name),
    last_name = COALESCE($3, last_name),
    bsn = COALESCE($4, bsn),
    date_of_birth = COALESCE($5, date_of_birth),
    gender = COALESCE($6::gender_enum, gender),
    care_type = COALESCE($7::care_type_enum, care_type),
    referring_org_id = COALESCE($8, referring_org_id),
    updated_at = NOW()
WHERE registration_form_id = $1
`

type UpdateClientByRegistrationFormIDParams struct {
	RegistrationFormID string           `json:"registration_form_id"`
	FirstName          *string          `json:"first_name"`
	LastName           *string          `json:"last_name"`
	Bsn                *string          `json:"bsn"`
	DateOfBirth        pgtype.Date      `json:"date_of_birth"`
	Gender             NullGenderEnum   `json:"gender"`
	CareType           NullCareTypeEnum `json:"care_type"`
	ReferringOrgID     *string          `json:"referring_org_id"`
}

func (q *Queries) UpdateClientByRegistrationFormID(ctx context.Context, arg UpdateClientByRegistrationFormIDParams) error {
	_, err := q.db.Exec(ctx, updateClientByRegistrationFormID,
		arg.RegistrationFormID,
		arg.FirstName,
		arg.LastName,
		arg.Bsn,
		arg.DateOfBirth,
		arg.Gender,
		arg.CareType,
		arg.ReferringOrgID,
	)
	return err
}
