// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: calendar.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addAppointmentParticipant = `-- name: AddAppointmentParticipant :exec
INSERT INTO appointment_participants (
    appointment_id, participant_id, participant_type
) VALUES (
    $1, $2, $3
)
`

type AddAppointmentParticipantParams struct {
	AppointmentID   string              `json:"appointment_id"`
	ParticipantID   string              `json:"participant_id"`
	ParticipantType ParticipantTypeEnum `json:"participant_type"`
}

func (q *Queries) AddAppointmentParticipant(ctx context.Context, arg AddAppointmentParticipantParams) error {
	_, err := q.db.Exec(ctx, addAppointmentParticipant, arg.AppointmentID, arg.ParticipantID, arg.ParticipantType)
	return err
}

const createAppointment = `-- name: CreateAppointment :one
INSERT INTO appointments (
    id, title, description, start_time, end_time, location, organizer_id, status, type, recurrence_rule
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, title, description, start_time, end_time, location, organizer_id, status, type, recurrence_rule, created_at, updated_at
`

type CreateAppointmentParams struct {
	ID             string                    `json:"id"`
	Title          string                    `json:"title"`
	Description    *string                   `json:"description"`
	StartTime      pgtype.Timestamptz        `json:"start_time"`
	EndTime        pgtype.Timestamptz        `json:"end_time"`
	Location       *string                   `json:"location"`
	OrganizerID    string                    `json:"organizer_id"`
	Status         NullAppointmentStatusEnum `json:"status"`
	Type           AppointmentTypeEnum       `json:"type"`
	RecurrenceRule *string                   `json:"recurrence_rule"`
}

func (q *Queries) CreateAppointment(ctx context.Context, arg CreateAppointmentParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, createAppointment,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.StartTime,
		arg.EndTime,
		arg.Location,
		arg.OrganizerID,
		arg.Status,
		arg.Type,
		arg.RecurrenceRule,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.StartTime,
		&i.EndTime,
		&i.Location,
		&i.OrganizerID,
		&i.Status,
		&i.Type,
		&i.RecurrenceRule,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createReminder = `-- name: CreateReminder :one
INSERT INTO reminders (
    id, user_id, title, description, due_time, is_completed
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, user_id, title, description, due_time, is_completed, created_at, updated_at
`

type CreateReminderParams struct {
	ID          string             `json:"id"`
	UserID      string             `json:"user_id"`
	Title       string             `json:"title"`
	Description *string            `json:"description"`
	DueTime     pgtype.Timestamptz `json:"due_time"`
	IsCompleted *bool              `json:"is_completed"`
}

func (q *Queries) CreateReminder(ctx context.Context, arg CreateReminderParams) (Reminder, error) {
	row := q.db.QueryRow(ctx, createReminder,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.DueTime,
		arg.IsCompleted,
	)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.DueTime,
		&i.IsCompleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAppointment = `-- name: DeleteAppointment :exec
DELETE FROM appointments WHERE id = $1
`

func (q *Queries) DeleteAppointment(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteAppointment, id)
	return err
}

const deleteReminder = `-- name: DeleteReminder :exec
DELETE FROM reminders WHERE id = $1
`

func (q *Queries) DeleteReminder(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteReminder, id)
	return err
}

const getAppointment = `-- name: GetAppointment :one
SELECT id, title, description, start_time, end_time, location, organizer_id, status, type, recurrence_rule, created_at, updated_at FROM appointments WHERE id = $1
`

func (q *Queries) GetAppointment(ctx context.Context, id string) (Appointment, error) {
	row := q.db.QueryRow(ctx, getAppointment, id)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.StartTime,
		&i.EndTime,
		&i.Location,
		&i.OrganizerID,
		&i.Status,
		&i.Type,
		&i.RecurrenceRule,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReminder = `-- name: GetReminder :one
SELECT id, user_id, title, description, due_time, is_completed, created_at, updated_at FROM reminders WHERE id = $1
`

func (q *Queries) GetReminder(ctx context.Context, id string) (Reminder, error) {
	row := q.db.QueryRow(ctx, getReminder, id)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.DueTime,
		&i.IsCompleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAppointmentParticipants = `-- name: ListAppointmentParticipants :many
SELECT appointment_id, participant_id, participant_type FROM appointment_participants WHERE appointment_id = $1
`

func (q *Queries) ListAppointmentParticipants(ctx context.Context, appointmentID string) ([]AppointmentParticipant, error) {
	rows, err := q.db.Query(ctx, listAppointmentParticipants, appointmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AppointmentParticipant{}
	for rows.Next() {
		var i AppointmentParticipant
		if err := rows.Scan(&i.AppointmentID, &i.ParticipantID, &i.ParticipantType); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppointmentsByOrganizer = `-- name: ListAppointmentsByOrganizer :many
SELECT id, title, description, start_time, end_time, location, organizer_id, status, type, recurrence_rule, created_at, updated_at FROM appointments WHERE organizer_id = $1 ORDER BY start_time ASC
`

func (q *Queries) ListAppointmentsByOrganizer(ctx context.Context, organizerID string) ([]Appointment, error) {
	rows, err := q.db.Query(ctx, listAppointmentsByOrganizer, organizerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Appointment{}
	for rows.Next() {
		var i Appointment
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.StartTime,
			&i.EndTime,
			&i.Location,
			&i.OrganizerID,
			&i.Status,
			&i.Type,
			&i.RecurrenceRule,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppointmentsByParticipant = `-- name: ListAppointmentsByParticipant :many
SELECT a.id, a.title, a.description, a.start_time, a.end_time, a.location, a.organizer_id, a.status, a.type, a.recurrence_rule, a.created_at, a.updated_at FROM appointments a
JOIN appointment_participants ap ON a.id = ap.appointment_id
WHERE ap.participant_id = $1 AND ap.participant_type = $2
ORDER BY a.start_time ASC
`

type ListAppointmentsByParticipantParams struct {
	ParticipantID   string              `json:"participant_id"`
	ParticipantType ParticipantTypeEnum `json:"participant_type"`
}

func (q *Queries) ListAppointmentsByParticipant(ctx context.Context, arg ListAppointmentsByParticipantParams) ([]Appointment, error) {
	rows, err := q.db.Query(ctx, listAppointmentsByParticipant, arg.ParticipantID, arg.ParticipantType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Appointment{}
	for rows.Next() {
		var i Appointment
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.StartTime,
			&i.EndTime,
			&i.Location,
			&i.OrganizerID,
			&i.Status,
			&i.Type,
			&i.RecurrenceRule,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAppointmentsByRange = `-- name: ListAppointmentsByRange :many
SELECT id, title, description, start_time, end_time, location, organizer_id, status, type, recurrence_rule, created_at, updated_at FROM appointments 
WHERE organizer_id = $1 
AND start_time >= $2::timestamptz 
AND start_time <= $3::timestamptz
ORDER BY start_time ASC
`

type ListAppointmentsByRangeParams struct {
	OrganizerID string             `json:"organizer_id"`
	StartTime   pgtype.Timestamptz `json:"start_time"`
	EndTime     pgtype.Timestamptz `json:"end_time"`
}

func (q *Queries) ListAppointmentsByRange(ctx context.Context, arg ListAppointmentsByRangeParams) ([]Appointment, error) {
	rows, err := q.db.Query(ctx, listAppointmentsByRange, arg.OrganizerID, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Appointment{}
	for rows.Next() {
		var i Appointment
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.StartTime,
			&i.EndTime,
			&i.Location,
			&i.OrganizerID,
			&i.Status,
			&i.Type,
			&i.RecurrenceRule,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecurringAppointments = `-- name: ListRecurringAppointments :many
SELECT id, title, description, start_time, end_time, location, organizer_id, status, type, recurrence_rule, created_at, updated_at FROM appointments 
WHERE organizer_id = $1 
AND recurrence_rule IS NOT NULL 
AND recurrence_rule <> ''
AND start_time <= $2::timestamptz
ORDER BY start_time ASC
`

type ListRecurringAppointmentsParams struct {
	OrganizerID string             `json:"organizer_id"`
	EndTime     pgtype.Timestamptz `json:"end_time"`
}

func (q *Queries) ListRecurringAppointments(ctx context.Context, arg ListRecurringAppointmentsParams) ([]Appointment, error) {
	rows, err := q.db.Query(ctx, listRecurringAppointments, arg.OrganizerID, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Appointment{}
	for rows.Next() {
		var i Appointment
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.StartTime,
			&i.EndTime,
			&i.Location,
			&i.OrganizerID,
			&i.Status,
			&i.Type,
			&i.RecurrenceRule,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRemindersByRange = `-- name: ListRemindersByRange :many
SELECT id, user_id, title, description, due_time, is_completed, created_at, updated_at FROM reminders 
WHERE user_id = $1 
AND due_time >= $2::timestamptz 
AND due_time <= $3::timestamptz
ORDER BY due_time ASC
`

type ListRemindersByRangeParams struct {
	UserID    string             `json:"user_id"`
	StartTime pgtype.Timestamptz `json:"start_time"`
	EndTime   pgtype.Timestamptz `json:"end_time"`
}

func (q *Queries) ListRemindersByRange(ctx context.Context, arg ListRemindersByRangeParams) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, listRemindersByRange, arg.UserID, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.DueTime,
			&i.IsCompleted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRemindersByUser = `-- name: ListRemindersByUser :many
SELECT id, user_id, title, description, due_time, is_completed, created_at, updated_at FROM reminders WHERE user_id = $1 ORDER BY due_time ASC
`

func (q *Queries) ListRemindersByUser(ctx context.Context, userID string) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, listRemindersByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.DueTime,
			&i.IsCompleted,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAppointmentParticipants = `-- name: RemoveAppointmentParticipants :exec
DELETE FROM appointment_participants WHERE appointment_id = $1
`

func (q *Queries) RemoveAppointmentParticipants(ctx context.Context, appointmentID string) error {
	_, err := q.db.Exec(ctx, removeAppointmentParticipants, appointmentID)
	return err
}

const updateAppointment = `-- name: UpdateAppointment :one
UPDATE appointments
SET title = CASE WHEN $1::text <> '' THEN $1::text ELSE title END,
    description = COALESCE($2, description),
    start_time = COALESCE($3, start_time),
    end_time = COALESCE($4, end_time),
    location = COALESCE($5, location),
    status = COALESCE($6, status),
    type = COALESCE($7, type),
    recurrence_rule = COALESCE($8, recurrence_rule),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $9
RETURNING id, title, description, start_time, end_time, location, organizer_id, status, type, recurrence_rule, created_at, updated_at
`

type UpdateAppointmentParams struct {
	Title          string                    `json:"title"`
	Description    *string                   `json:"description"`
	StartTime      pgtype.Timestamptz        `json:"start_time"`
	EndTime        pgtype.Timestamptz        `json:"end_time"`
	Location       *string                   `json:"location"`
	Status         NullAppointmentStatusEnum `json:"status"`
	Type           NullAppointmentTypeEnum   `json:"type"`
	RecurrenceRule *string                   `json:"recurrence_rule"`
	ID             string                    `json:"id"`
}

func (q *Queries) UpdateAppointment(ctx context.Context, arg UpdateAppointmentParams) (Appointment, error) {
	row := q.db.QueryRow(ctx, updateAppointment,
		arg.Title,
		arg.Description,
		arg.StartTime,
		arg.EndTime,
		arg.Location,
		arg.Status,
		arg.Type,
		arg.RecurrenceRule,
		arg.ID,
	)
	var i Appointment
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.StartTime,
		&i.EndTime,
		&i.Location,
		&i.OrganizerID,
		&i.Status,
		&i.Type,
		&i.RecurrenceRule,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateReminder = `-- name: UpdateReminder :one
UPDATE reminders
SET title = CASE WHEN $1::text <> '' THEN $1::text ELSE title END,
    description = COALESCE($2, description),
    due_time = COALESCE($3, due_time),
    is_completed = COALESCE($4, is_completed),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $5
RETURNING id, user_id, title, description, due_time, is_completed, created_at, updated_at
`

type UpdateReminderParams struct {
	Title       string             `json:"title"`
	Description *string            `json:"description"`
	DueTime     pgtype.Timestamptz `json:"due_time"`
	IsCompleted *bool              `json:"is_completed"`
	ID          string             `json:"id"`
}

func (q *Queries) UpdateReminder(ctx context.Context, arg UpdateReminderParams) (Reminder, error) {
	row := q.db.QueryRow(ctx, updateReminder,
		arg.Title,
		arg.Description,
		arg.DueTime,
		arg.IsCompleted,
		arg.ID,
	)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.DueTime,
		&i.IsCompleted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
