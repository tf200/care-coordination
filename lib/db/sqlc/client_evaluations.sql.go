// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: client_evaluations.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createClientEvaluation = `-- name: CreateClientEvaluation :one
INSERT INTO client_evaluations (
    id,
    client_id,
    coordinator_id,
    evaluation_date,
    overall_notes
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, client_id, coordinator_id, evaluation_date, overall_notes, created_at, updated_at
`

type CreateClientEvaluationParams struct {
	ID             string      `json:"id"`
	ClientID       string      `json:"client_id"`
	CoordinatorID  string      `json:"coordinator_id"`
	EvaluationDate pgtype.Date `json:"evaluation_date"`
	OverallNotes   *string     `json:"overall_notes"`
}

func (q *Queries) CreateClientEvaluation(ctx context.Context, arg CreateClientEvaluationParams) (ClientEvaluation, error) {
	row := q.db.QueryRow(ctx, createClientEvaluation,
		arg.ID,
		arg.ClientID,
		arg.CoordinatorID,
		arg.EvaluationDate,
		arg.OverallNotes,
	)
	var i ClientEvaluation
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.CoordinatorID,
		&i.EvaluationDate,
		&i.OverallNotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createGoalProgressLog = `-- name: CreateGoalProgressLog :exec
INSERT INTO goal_progress_logs (
    id,
    evaluation_id,
    goal_id,
    status,
    progress_notes
) VALUES (
    $1, $2, $3, $4, $5
)
`

type CreateGoalProgressLogParams struct {
	ID            string             `json:"id"`
	EvaluationID  string             `json:"evaluation_id"`
	GoalID        string             `json:"goal_id"`
	Status        GoalProgressStatus `json:"status"`
	ProgressNotes *string            `json:"progress_notes"`
}

func (q *Queries) CreateGoalProgressLog(ctx context.Context, arg CreateGoalProgressLogParams) error {
	_, err := q.db.Exec(ctx, createGoalProgressLog,
		arg.ID,
		arg.EvaluationID,
		arg.GoalID,
		arg.Status,
		arg.ProgressNotes,
	)
	return err
}

const getClientEvaluationHistory = `-- name: GetClientEvaluationHistory :many
SELECT 
    e.id as evaluation_id,
    e.evaluation_date,
    e.overall_notes,
    g.id as goal_id,
    g.title as goal_title,
    l.status,
    l.progress_notes,
    emp.first_name as coordinator_first_name,
    emp.last_name as coordinator_last_name
FROM client_evaluations e
JOIN goal_progress_logs l ON e.id = l.evaluation_id
JOIN client_goals g ON l.goal_id = g.id
JOIN employees emp ON e.coordinator_id = emp.id
WHERE e.client_id = $1
ORDER BY e.evaluation_date DESC, g.title ASC
`

type GetClientEvaluationHistoryRow struct {
	EvaluationID         string             `json:"evaluation_id"`
	EvaluationDate       pgtype.Date        `json:"evaluation_date"`
	OverallNotes         *string            `json:"overall_notes"`
	GoalID               string             `json:"goal_id"`
	GoalTitle            string             `json:"goal_title"`
	Status               GoalProgressStatus `json:"status"`
	ProgressNotes        *string            `json:"progress_notes"`
	CoordinatorFirstName string             `json:"coordinator_first_name"`
	CoordinatorLastName  string             `json:"coordinator_last_name"`
}

func (q *Queries) GetClientEvaluationHistory(ctx context.Context, clientID string) ([]GetClientEvaluationHistoryRow, error) {
	rows, err := q.db.Query(ctx, getClientEvaluationHistory, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClientEvaluationHistoryRow{}
	for rows.Next() {
		var i GetClientEvaluationHistoryRow
		if err := rows.Scan(
			&i.EvaluationID,
			&i.EvaluationDate,
			&i.OverallNotes,
			&i.GoalID,
			&i.GoalTitle,
			&i.Status,
			&i.ProgressNotes,
			&i.CoordinatorFirstName,
			&i.CoordinatorLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCriticalEvaluations = `-- name: GetCriticalEvaluations :many
SELECT 
    c.id,
    c.first_name,
    c.last_name,
    c.next_evaluation_date,
    c.evaluation_interval_weeks,
    l.name as location_name,
    e.first_name as coordinator_first_name,
    e.last_name as coordinator_last_name,
    COUNT(*) OVER() as total_count
FROM clients c
JOIN locations l ON c.assigned_location_id = l.id
JOIN employees e ON c.coordinator_id = e.id
WHERE c.status = 'in_care' 
  AND c.next_evaluation_date IS NOT NULL
  AND c.next_evaluation_date <= (CURRENT_DATE + INTERVAL '7 days')::date
ORDER BY c.next_evaluation_date ASC
LIMIT $1 OFFSET $2
`

type GetCriticalEvaluationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetCriticalEvaluationsRow struct {
	ID                      string      `json:"id"`
	FirstName               string      `json:"first_name"`
	LastName                string      `json:"last_name"`
	NextEvaluationDate      pgtype.Date `json:"next_evaluation_date"`
	EvaluationIntervalWeeks *int32      `json:"evaluation_interval_weeks"`
	LocationName            string      `json:"location_name"`
	CoordinatorFirstName    string      `json:"coordinator_first_name"`
	CoordinatorLastName     string      `json:"coordinator_last_name"`
	TotalCount              int64       `json:"total_count"`
}

func (q *Queries) GetCriticalEvaluations(ctx context.Context, arg GetCriticalEvaluationsParams) ([]GetCriticalEvaluationsRow, error) {
	rows, err := q.db.Query(ctx, getCriticalEvaluations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCriticalEvaluationsRow{}
	for rows.Next() {
		var i GetCriticalEvaluationsRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.NextEvaluationDate,
			&i.EvaluationIntervalWeeks,
			&i.LocationName,
			&i.CoordinatorFirstName,
			&i.CoordinatorLastName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastClientEvaluation = `-- name: GetLastClientEvaluation :many
SELECT 
    e.id as evaluation_id,
    e.evaluation_date,
    e.overall_notes,
    emp.first_name as coordinator_first_name,
    emp.last_name as coordinator_last_name,
    g.id as goal_id,
    g.title as goal_title,
    l.status,
    l.progress_notes
FROM client_evaluations e
JOIN goal_progress_logs l ON e.id = l.evaluation_id
JOIN client_goals g ON l.goal_id = g.id
JOIN employees emp ON e.coordinator_id = emp.id
WHERE e.client_id = $1
ORDER BY e.evaluation_date DESC, g.title ASC
LIMIT (SELECT COUNT(*) FROM goal_progress_logs WHERE evaluation_id = (
    SELECT id FROM client_evaluations WHERE client_id = $1 ORDER BY evaluation_date DESC LIMIT 1
))
`

type GetLastClientEvaluationRow struct {
	EvaluationID         string             `json:"evaluation_id"`
	EvaluationDate       pgtype.Date        `json:"evaluation_date"`
	OverallNotes         *string            `json:"overall_notes"`
	CoordinatorFirstName string             `json:"coordinator_first_name"`
	CoordinatorLastName  string             `json:"coordinator_last_name"`
	GoalID               string             `json:"goal_id"`
	GoalTitle            string             `json:"goal_title"`
	Status               GoalProgressStatus `json:"status"`
	ProgressNotes        *string            `json:"progress_notes"`
}

func (q *Queries) GetLastClientEvaluation(ctx context.Context, clientID string) ([]GetLastClientEvaluationRow, error) {
	rows, err := q.db.Query(ctx, getLastClientEvaluation, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLastClientEvaluationRow{}
	for rows.Next() {
		var i GetLastClientEvaluationRow
		if err := rows.Scan(
			&i.EvaluationID,
			&i.EvaluationDate,
			&i.OverallNotes,
			&i.CoordinatorFirstName,
			&i.CoordinatorLastName,
			&i.GoalID,
			&i.GoalTitle,
			&i.Status,
			&i.ProgressNotes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentEvaluationsGlobal = `-- name: GetRecentEvaluationsGlobal :many
SELECT 
    e.id as evaluation_id,
    e.evaluation_date,
    c.first_name as client_first_name,
    c.last_name as client_last_name,
    emp.first_name as coordinator_first_name,
    emp.last_name as coordinator_last_name,
    (SELECT COUNT(*) FROM goal_progress_logs WHERE evaluation_id = e.id) as total_goals,
    (SELECT COUNT(*) FROM goal_progress_logs WHERE evaluation_id = e.id AND status = 'achieved') as goals_achieved,
    COUNT(*) OVER() as total_count
FROM client_evaluations e
JOIN clients c ON e.client_id = c.id
JOIN employees emp ON e.coordinator_id = emp.id
ORDER BY e.evaluation_date DESC
LIMIT $1 OFFSET $2
`

type GetRecentEvaluationsGlobalParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetRecentEvaluationsGlobalRow struct {
	EvaluationID         string      `json:"evaluation_id"`
	EvaluationDate       pgtype.Date `json:"evaluation_date"`
	ClientFirstName      string      `json:"client_first_name"`
	ClientLastName       string      `json:"client_last_name"`
	CoordinatorFirstName string      `json:"coordinator_first_name"`
	CoordinatorLastName  string      `json:"coordinator_last_name"`
	TotalGoals           int64       `json:"total_goals"`
	GoalsAchieved        int64       `json:"goals_achieved"`
	TotalCount           int64       `json:"total_count"`
}

func (q *Queries) GetRecentEvaluationsGlobal(ctx context.Context, arg GetRecentEvaluationsGlobalParams) ([]GetRecentEvaluationsGlobalRow, error) {
	rows, err := q.db.Query(ctx, getRecentEvaluationsGlobal, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentEvaluationsGlobalRow{}
	for rows.Next() {
		var i GetRecentEvaluationsGlobalRow
		if err := rows.Scan(
			&i.EvaluationID,
			&i.EvaluationDate,
			&i.ClientFirstName,
			&i.ClientLastName,
			&i.CoordinatorFirstName,
			&i.CoordinatorLastName,
			&i.TotalGoals,
			&i.GoalsAchieved,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduledEvaluations = `-- name: GetScheduledEvaluations :many
SELECT 
    c.id,
    c.first_name,
    c.last_name,
    c.next_evaluation_date,
    c.evaluation_interval_weeks,
    l.name as location_name,
    e.first_name as coordinator_first_name,
    e.last_name as coordinator_last_name,
    COUNT(*) OVER() as total_count
FROM clients c
JOIN locations l ON c.assigned_location_id = l.id
JOIN employees e ON c.coordinator_id = e.id
WHERE c.status = 'in_care' 
  AND c.next_evaluation_date IS NOT NULL
  AND c.next_evaluation_date > (CURRENT_DATE + INTERVAL '7 days')::date
  AND c.next_evaluation_date <= (CURRENT_DATE + INTERVAL '30 days')::date
ORDER BY c.next_evaluation_date ASC
LIMIT $1 OFFSET $2
`

type GetScheduledEvaluationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetScheduledEvaluationsRow struct {
	ID                      string      `json:"id"`
	FirstName               string      `json:"first_name"`
	LastName                string      `json:"last_name"`
	NextEvaluationDate      pgtype.Date `json:"next_evaluation_date"`
	EvaluationIntervalWeeks *int32      `json:"evaluation_interval_weeks"`
	LocationName            string      `json:"location_name"`
	CoordinatorFirstName    string      `json:"coordinator_first_name"`
	CoordinatorLastName     string      `json:"coordinator_last_name"`
	TotalCount              int64       `json:"total_count"`
}

func (q *Queries) GetScheduledEvaluations(ctx context.Context, arg GetScheduledEvaluationsParams) ([]GetScheduledEvaluationsRow, error) {
	rows, err := q.db.Query(ctx, getScheduledEvaluations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetScheduledEvaluationsRow{}
	for rows.Next() {
		var i GetScheduledEvaluationsRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.NextEvaluationDate,
			&i.EvaluationIntervalWeeks,
			&i.LocationName,
			&i.CoordinatorFirstName,
			&i.CoordinatorLastName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateClientNextEvaluationDate = `-- name: UpdateClientNextEvaluationDate :exec
UPDATE clients 
SET next_evaluation_date = $2, updated_at = NOW() 
WHERE id = $1
`

type UpdateClientNextEvaluationDateParams struct {
	ID                 string      `json:"id"`
	NextEvaluationDate pgtype.Date `json:"next_evaluation_date"`
}

func (q *Queries) UpdateClientNextEvaluationDate(ctx context.Context, arg UpdateClientNextEvaluationDateParams) error {
	_, err := q.db.Exec(ctx, updateClientNextEvaluationDate, arg.ID, arg.NextEvaluationDate)
	return err
}
