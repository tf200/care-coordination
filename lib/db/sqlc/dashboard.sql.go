// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: dashboard.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCareTypeDistribution = `-- name: GetCareTypeDistribution :one
SELECT
    (SELECT COUNT(*) FROM clients WHERE status = 'in_care' AND care_type = 'protected_living') as protected_living,
    (SELECT COUNT(*) FROM clients WHERE status = 'in_care' AND care_type = 'semi_independent_living') as semi_independent_living,
    (SELECT COUNT(*) FROM clients WHERE status = 'in_care' AND care_type = 'independent_assisted_living') as independent_assisted_living,
    (SELECT COUNT(*) FROM clients WHERE status = 'in_care' AND care_type = 'ambulatory_care') as ambulatory_care,
    (SELECT COUNT(*) FROM clients WHERE status = 'in_care') as total
`

type GetCareTypeDistributionRow struct {
	ProtectedLiving           int64 `json:"protected_living"`
	SemiIndependentLiving     int64 `json:"semi_independent_living"`
	IndependentAssistedLiving int64 `json:"independent_assisted_living"`
	AmbulatoryCare            int64 `json:"ambulatory_care"`
	Total                     int64 `json:"total"`
}

func (q *Queries) GetCareTypeDistribution(ctx context.Context) (GetCareTypeDistributionRow, error) {
	row := q.db.QueryRow(ctx, getCareTypeDistribution)
	var i GetCareTypeDistributionRow
	err := row.Scan(
		&i.ProtectedLiving,
		&i.SemiIndependentLiving,
		&i.IndependentAssistedLiving,
		&i.AmbulatoryCare,
		&i.Total,
	)
	return i, err
}

const getCoordinatorClients = `-- name: GetCoordinatorClients :many
SELECT
    c.id,
    c.first_name,
    c.last_name,
    c.care_type,
    c.status,
    c.care_end_date,
    c.next_evaluation_date,
    l.name as location_name
FROM clients c
LEFT JOIN locations l ON c.assigned_location_id = l.id
WHERE c.coordinator_id = $1
AND c.status IN ('in_care', 'waiting_list')
ORDER BY c.care_end_date ASC NULLS LAST, c.next_evaluation_date ASC NULLS LAST
`

type GetCoordinatorClientsRow struct {
	ID                 string           `json:"id"`
	FirstName          string           `json:"first_name"`
	LastName           string           `json:"last_name"`
	CareType           CareTypeEnum     `json:"care_type"`
	Status             ClientStatusEnum `json:"status"`
	CareEndDate        pgtype.Date      `json:"care_end_date"`
	NextEvaluationDate pgtype.Date      `json:"next_evaluation_date"`
	LocationName       *string          `json:"location_name"`
}

func (q *Queries) GetCoordinatorClients(ctx context.Context, coordinatorID string) ([]GetCoordinatorClientsRow, error) {
	rows, err := q.db.Query(ctx, getCoordinatorClients, coordinatorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCoordinatorClientsRow{}
	for rows.Next() {
		var i GetCoordinatorClientsRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.CareType,
			&i.Status,
			&i.CareEndDate,
			&i.NextEvaluationDate,
			&i.LocationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoordinatorDraftEvaluationClients = `-- name: GetCoordinatorDraftEvaluationClients :many
SELECT c.id, c.first_name, c.last_name
FROM clients c
JOIN client_evaluations ce ON ce.client_id = c.id
WHERE ce.coordinator_id = $1
AND ce.status = 'draft'
LIMIT 5
`

type GetCoordinatorDraftEvaluationClientsRow struct {
	ID        string `json:"id"`
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
}

func (q *Queries) GetCoordinatorDraftEvaluationClients(ctx context.Context, coordinatorID string) ([]GetCoordinatorDraftEvaluationClientsRow, error) {
	rows, err := q.db.Query(ctx, getCoordinatorDraftEvaluationClients, coordinatorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCoordinatorDraftEvaluationClientsRow{}
	for rows.Next() {
		var i GetCoordinatorDraftEvaluationClientsRow
		if err := rows.Scan(&i.ID, &i.FirstName, &i.LastName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoordinatorExpiringContractClients = `-- name: GetCoordinatorExpiringContractClients :many
SELECT id, first_name, last_name
FROM clients
WHERE coordinator_id = $1
AND status = 'in_care'
AND care_end_date IS NOT NULL
AND care_end_date >= CURRENT_DATE
AND care_end_date <= (CURRENT_DATE + INTERVAL '7 days')::date
LIMIT 5
`

type GetCoordinatorExpiringContractClientsRow struct {
	ID        string `json:"id"`
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
}

func (q *Queries) GetCoordinatorExpiringContractClients(ctx context.Context, coordinatorID string) ([]GetCoordinatorExpiringContractClientsRow, error) {
	rows, err := q.db.Query(ctx, getCoordinatorExpiringContractClients, coordinatorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCoordinatorExpiringContractClientsRow{}
	for rows.Next() {
		var i GetCoordinatorExpiringContractClientsRow
		if err := rows.Scan(&i.ID, &i.FirstName, &i.LastName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoordinatorGoalsProgress = `-- name: GetCoordinatorGoalsProgress :one
WITH coordinator_goals AS (
    SELECT cg.id as goal_id
    FROM client_goals cg
    JOIN clients c ON cg.client_id = c.id
    WHERE c.coordinator_id = $1
    AND c.status = 'in_care'
),
latest_progress AS (
    SELECT DISTINCT ON (gpl.goal_id) 
        gpl.goal_id,
        gpl.status
    FROM goal_progress_logs gpl
    WHERE gpl.goal_id IN (SELECT goal_id FROM coordinator_goals)
    ORDER BY gpl.goal_id, gpl.created_at DESC
)
SELECT
    (SELECT COUNT(*) FROM coordinator_goals)::bigint as total,
    COALESCE((SELECT COUNT(*) FROM latest_progress WHERE status IN ('on_track', 'in_progress', 'starting')), 0)::bigint as on_track,
    COALESCE((SELECT COUNT(*) FROM latest_progress WHERE status IN ('delayed', 'stagnant', 'deteriorating')), 0)::bigint as delayed,
    COALESCE((SELECT COUNT(*) FROM latest_progress WHERE status = 'achieved'), 0)::bigint as achieved,
    (
        (SELECT COUNT(*) FROM coordinator_goals) - 
        (SELECT COUNT(*) FROM latest_progress WHERE status != 'not_started')
    )::bigint as not_started
`

type GetCoordinatorGoalsProgressRow struct {
	Total      int64 `json:"total"`
	OnTrack    int64 `json:"on_track"`
	Delayed    int64 `json:"delayed"`
	Achieved   int64 `json:"achieved"`
	NotStarted int64 `json:"not_started"`
}

func (q *Queries) GetCoordinatorGoalsProgress(ctx context.Context, coordinatorID string) (GetCoordinatorGoalsProgressRow, error) {
	row := q.db.QueryRow(ctx, getCoordinatorGoalsProgress, coordinatorID)
	var i GetCoordinatorGoalsProgressRow
	err := row.Scan(
		&i.Total,
		&i.OnTrack,
		&i.Delayed,
		&i.Achieved,
		&i.NotStarted,
	)
	return i, err
}

const getCoordinatorIncidents = `-- name: GetCoordinatorIncidents :many
SELECT
    i.id,
    i.incident_type,
    i.incident_severity,
    i.incident_date,
    i.status,
    c.first_name as client_first_name,
    c.last_name as client_last_name
FROM incidents i
JOIN clients c ON i.client_id = c.id
WHERE i.coordinator_id = $1
AND i.is_deleted = FALSE
ORDER BY i.incident_date DESC
LIMIT 10
`

type GetCoordinatorIncidentsRow struct {
	ID               string               `json:"id"`
	IncidentType     IncidentTypeEnum     `json:"incident_type"`
	IncidentSeverity IncidentSeverityEnum `json:"incident_severity"`
	IncidentDate     pgtype.Date          `json:"incident_date"`
	Status           IncidentStatusEnum   `json:"status"`
	ClientFirstName  string               `json:"client_first_name"`
	ClientLastName   string               `json:"client_last_name"`
}

func (q *Queries) GetCoordinatorIncidents(ctx context.Context, coordinatorID string) ([]GetCoordinatorIncidentsRow, error) {
	rows, err := q.db.Query(ctx, getCoordinatorIncidents, coordinatorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCoordinatorIncidentsRow{}
	for rows.Next() {
		var i GetCoordinatorIncidentsRow
		if err := rows.Scan(
			&i.ID,
			&i.IncidentType,
			&i.IncidentSeverity,
			&i.IncidentDate,
			&i.Status,
			&i.ClientFirstName,
			&i.ClientLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoordinatorLongWaitingClients = `-- name: GetCoordinatorLongWaitingClients :many
SELECT id, first_name, last_name
FROM clients
WHERE coordinator_id = $1
AND status = 'waiting_list'
AND waiting_list_date IS NOT NULL
AND waiting_list_date < (CURRENT_DATE - INTERVAL '60 days')::date
LIMIT 5
`

type GetCoordinatorLongWaitingClientsRow struct {
	ID        string `json:"id"`
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
}

func (q *Queries) GetCoordinatorLongWaitingClients(ctx context.Context, coordinatorID string) ([]GetCoordinatorLongWaitingClientsRow, error) {
	rows, err := q.db.Query(ctx, getCoordinatorLongWaitingClients, coordinatorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCoordinatorLongWaitingClientsRow{}
	for rows.Next() {
		var i GetCoordinatorLongWaitingClientsRow
		if err := rows.Scan(&i.ID, &i.FirstName, &i.LastName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoordinatorOverdueEvaluationClients = `-- name: GetCoordinatorOverdueEvaluationClients :many
SELECT id, first_name, last_name
FROM clients
WHERE coordinator_id = $1
AND status = 'in_care'
AND next_evaluation_date IS NOT NULL
AND next_evaluation_date < CURRENT_DATE
LIMIT 5
`

type GetCoordinatorOverdueEvaluationClientsRow struct {
	ID        string `json:"id"`
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
}

func (q *Queries) GetCoordinatorOverdueEvaluationClients(ctx context.Context, coordinatorID string) ([]GetCoordinatorOverdueEvaluationClientsRow, error) {
	rows, err := q.db.Query(ctx, getCoordinatorOverdueEvaluationClients, coordinatorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCoordinatorOverdueEvaluationClientsRow{}
	for rows.Next() {
		var i GetCoordinatorOverdueEvaluationClientsRow
		if err := rows.Scan(&i.ID, &i.FirstName, &i.LastName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoordinatorReminders = `-- name: GetCoordinatorReminders :many
SELECT
    r.id,
    r.title,
    r.due_time
FROM reminders r
WHERE r.user_id = $1
AND r.is_completed = FALSE
ORDER BY r.due_time ASC
LIMIT 10
`

type GetCoordinatorRemindersRow struct {
	ID      string             `json:"id"`
	Title   string             `json:"title"`
	DueTime pgtype.Timestamptz `json:"due_time"`
}

func (q *Queries) GetCoordinatorReminders(ctx context.Context, userID string) ([]GetCoordinatorRemindersRow, error) {
	rows, err := q.db.Query(ctx, getCoordinatorReminders, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCoordinatorRemindersRow{}
	for rows.Next() {
		var i GetCoordinatorRemindersRow
		if err := rows.Scan(&i.ID, &i.Title, &i.DueTime); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoordinatorStats = `-- name: GetCoordinatorStats :one
SELECT
    (SELECT COUNT(*) FROM clients c1
     WHERE c1.coordinator_id = $1 
     AND c1.status = 'in_care')::bigint as my_active_clients,
    
    (SELECT COUNT(*) FROM clients c2
     WHERE c2.coordinator_id = $1 
     AND c2.status = 'in_care' 
     AND c2.next_evaluation_date IS NOT NULL 
     AND c2.next_evaluation_date >= CURRENT_DATE
     AND c2.next_evaluation_date <= (CURRENT_DATE + INTERVAL '30 days')::date)::bigint as my_upcoming_evaluations,
    
    (SELECT COUNT(*) FROM intake_forms i
     WHERE i.coordinator_id = $1 
     AND i.status = 'pending')::bigint as my_pending_intakes,
    
    (SELECT COUNT(*) FROM clients c3
     WHERE c3.coordinator_id = $1 
     AND c3.status = 'waiting_list')::bigint as my_waiting_list_clients
`

type GetCoordinatorStatsRow struct {
	MyActiveClients       int64 `json:"my_active_clients"`
	MyUpcomingEvaluations int64 `json:"my_upcoming_evaluations"`
	MyPendingIntakes      int64 `json:"my_pending_intakes"`
	MyWaitingListClients  int64 `json:"my_waiting_list_clients"`
}

func (q *Queries) GetCoordinatorStats(ctx context.Context, coordinatorID string) (GetCoordinatorStatsRow, error) {
	row := q.db.QueryRow(ctx, getCoordinatorStats, coordinatorID)
	var i GetCoordinatorStatsRow
	err := row.Scan(
		&i.MyActiveClients,
		&i.MyUpcomingEvaluations,
		&i.MyPendingIntakes,
		&i.MyWaitingListClients,
	)
	return i, err
}

const getCoordinatorTodaySchedule = `-- name: GetCoordinatorTodaySchedule :many
SELECT
    a.id,
    a.title,
    a.type,
    a.start_time,
    a.end_time,
    a.location,
    a.status,
    -- Get client participant if exists
    COALESCE(
        (SELECT c.id FROM clients c 
         JOIN appointment_participants ap ON ap.participant_id = c.id 
         WHERE ap.appointment_id = a.id AND ap.participant_type = 'client' 
         LIMIT 1), 
        ''
    )::text as client_id,
    COALESCE(
        (SELECT CONCAT(c.first_name, ' ', c.last_name) FROM clients c 
         JOIN appointment_participants ap ON ap.participant_id = c.id 
         WHERE ap.appointment_id = a.id AND ap.participant_type = 'client' 
         LIMIT 1), 
        ''
    )::text as client_name,
    -- Get location info if linked
    COALESCE(
        (SELECT l.id FROM locations l WHERE l.name = a.location LIMIT 1),
        ''
    )::text as location_id,
    COALESCE(a.location, '')::text as location_name
FROM appointments a
WHERE 
    DATE(a.start_time AT TIME ZONE 'UTC') = CURRENT_DATE
    AND (
        a.organizer_id = $1
        OR EXISTS (
            SELECT 1 FROM appointment_participants ap 
            WHERE ap.appointment_id = a.id 
            AND ap.participant_id = $1 
            AND ap.participant_type = 'employee'
        )
    )
ORDER BY a.start_time ASC
`

type GetCoordinatorTodayScheduleRow struct {
	ID           string                    `json:"id"`
	Title        string                    `json:"title"`
	Type         AppointmentTypeEnum       `json:"type"`
	StartTime    pgtype.Timestamptz        `json:"start_time"`
	EndTime      pgtype.Timestamptz        `json:"end_time"`
	Location     *string                   `json:"location"`
	Status       NullAppointmentStatusEnum `json:"status"`
	ClientID     string                    `json:"client_id"`
	ClientName   string                    `json:"client_name"`
	LocationID   string                    `json:"location_id"`
	LocationName string                    `json:"location_name"`
}

func (q *Queries) GetCoordinatorTodaySchedule(ctx context.Context, organizerID string) ([]GetCoordinatorTodayScheduleRow, error) {
	rows, err := q.db.Query(ctx, getCoordinatorTodaySchedule, organizerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCoordinatorTodayScheduleRow{}
	for rows.Next() {
		var i GetCoordinatorTodayScheduleRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Type,
			&i.StartTime,
			&i.EndTime,
			&i.Location,
			&i.Status,
			&i.ClientID,
			&i.ClientName,
			&i.LocationID,
			&i.LocationName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoordinatorUnresolvedIncidentClients = `-- name: GetCoordinatorUnresolvedIncidentClients :many
SELECT DISTINCT c.id, c.first_name, c.last_name
FROM clients c
JOIN incidents i ON i.client_id = c.id
WHERE i.coordinator_id = $1
AND (i.status = 'pending' OR i.status = 'under_investigation')
AND i.is_deleted = FALSE
LIMIT 5
`

type GetCoordinatorUnresolvedIncidentClientsRow struct {
	ID        string `json:"id"`
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
}

func (q *Queries) GetCoordinatorUnresolvedIncidentClients(ctx context.Context, coordinatorID string) ([]GetCoordinatorUnresolvedIncidentClientsRow, error) {
	rows, err := q.db.Query(ctx, getCoordinatorUnresolvedIncidentClients, coordinatorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCoordinatorUnresolvedIncidentClientsRow{}
	for rows.Next() {
		var i GetCoordinatorUnresolvedIncidentClientsRow
		if err := rows.Scan(&i.ID, &i.FirstName, &i.LastName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoordinatorUrgentAlertsData = `-- name: GetCoordinatorUrgentAlertsData :one

SELECT
    -- Overdue evaluations for coordinator's clients
    (SELECT COUNT(*) FROM clients c1
     WHERE c1.coordinator_id = $1
     AND c1.status = 'in_care' 
     AND c1.next_evaluation_date IS NOT NULL 
     AND c1.next_evaluation_date < CURRENT_DATE)::bigint as overdue_evaluations,
    
    -- Contracts expiring within 7 days for coordinator's clients
    (SELECT COUNT(*) FROM clients c2
     WHERE c2.coordinator_id = $1
     AND c2.status = 'in_care' 
     AND c2.care_end_date IS NOT NULL 
     AND c2.care_end_date >= CURRENT_DATE
     AND c2.care_end_date <= (CURRENT_DATE + INTERVAL '7 days')::date)::bigint as expiring_contracts,
    
    -- Draft evaluations not completed by coordinator
    (SELECT COUNT(*) FROM client_evaluations ce
     WHERE ce.coordinator_id = $1
     AND ce.status = 'draft')::bigint as draft_evaluations,
    
    -- Unresolved incidents for coordinator's clients
    (SELECT COUNT(*) FROM incidents i
     WHERE i.coordinator_id = $1
     AND (i.status = 'pending' OR i.status = 'under_investigation')
     AND i.is_deleted = FALSE)::bigint as unresolved_incidents,
    
    -- Waiting list clients > 60 days for coordinator
    (SELECT COUNT(*) FROM clients c3
     WHERE c3.coordinator_id = $1
     AND c3.status = 'waiting_list' 
     AND c3.waiting_list_date IS NOT NULL
     AND c3.waiting_list_date < (CURRENT_DATE - INTERVAL '60 days')::date)::bigint as long_waiting
`

type GetCoordinatorUrgentAlertsDataRow struct {
	OverdueEvaluations  int64 `json:"overdue_evaluations"`
	ExpiringContracts   int64 `json:"expiring_contracts"`
	DraftEvaluations    int64 `json:"draft_evaluations"`
	UnresolvedIncidents int64 `json:"unresolved_incidents"`
	LongWaiting         int64 `json:"long_waiting"`
}

// ============================================================
// Coordinator Dashboard
// ============================================================
func (q *Queries) GetCoordinatorUrgentAlertsData(ctx context.Context, coordinatorID string) (GetCoordinatorUrgentAlertsDataRow, error) {
	row := q.db.QueryRow(ctx, getCoordinatorUrgentAlertsData, coordinatorID)
	var i GetCoordinatorUrgentAlertsDataRow
	err := row.Scan(
		&i.OverdueEvaluations,
		&i.ExpiringContracts,
		&i.DraftEvaluations,
		&i.UnresolvedIncidents,
		&i.LongWaiting,
	)
	return i, err
}

const getCriticalAlertsData = `-- name: GetCriticalAlertsData :one
SELECT
    -- Overdue evaluations (next_evaluation_date < today)
    (SELECT COUNT(*) FROM clients 
     WHERE status = 'in_care' 
     AND next_evaluation_date IS NOT NULL 
     AND next_evaluation_date < CURRENT_DATE) as overdue_evaluations,
    
    -- Care end date approaching (within 30 days)
    (SELECT COUNT(*) FROM clients 
     WHERE status = 'in_care' 
     AND care_end_date IS NOT NULL 
     AND care_end_date <= (CURRENT_DATE + INTERVAL '30 days')::date
     AND care_end_date >= CURRENT_DATE) as care_ending_soon,
    
    -- Open incidents (pending or under_investigation)
    (SELECT COUNT(*) FROM incidents 
     WHERE (status = 'pending' OR status = 'under_investigation') 
     AND is_deleted = FALSE) as open_incidents,
    
    -- Severe incidents count (for description)
    (SELECT COUNT(*) FROM incidents 
     WHERE (status = 'pending' OR status = 'under_investigation') 
     AND incident_severity = 'severe'
     AND is_deleted = FALSE) as severe_incidents,
    
    -- Moderate incidents count (for description)
    (SELECT COUNT(*) FROM incidents 
     WHERE (status = 'pending' OR status = 'under_investigation') 
     AND incident_severity = 'moderate'
     AND is_deleted = FALSE) as moderate_incidents,
    
    -- High priority waiting list
    (SELECT COUNT(*) FROM clients 
     WHERE status = 'waiting_list' 
     AND waiting_list_priority = 'high') as high_priority_waiting,
    
    -- Pending location transfers
    (SELECT COUNT(*) FROM client_location_transfers 
     WHERE status = 'pending') as pending_transfers
`

type GetCriticalAlertsDataRow struct {
	OverdueEvaluations  int64 `json:"overdue_evaluations"`
	CareEndingSoon      int64 `json:"care_ending_soon"`
	OpenIncidents       int64 `json:"open_incidents"`
	SevereIncidents     int64 `json:"severe_incidents"`
	ModerateIncidents   int64 `json:"moderate_incidents"`
	HighPriorityWaiting int64 `json:"high_priority_waiting"`
	PendingTransfers    int64 `json:"pending_transfers"`
}

func (q *Queries) GetCriticalAlertsData(ctx context.Context) (GetCriticalAlertsDataRow, error) {
	row := q.db.QueryRow(ctx, getCriticalAlertsData)
	var i GetCriticalAlertsDataRow
	err := row.Scan(
		&i.OverdueEvaluations,
		&i.CareEndingSoon,
		&i.OpenIncidents,
		&i.SevereIncidents,
		&i.ModerateIncidents,
		&i.HighPriorityWaiting,
		&i.PendingTransfers,
	)
	return i, err
}

const getDashboardDischargeStats = `-- name: GetDashboardDischargeStats :one
SELECT
    -- Discharged this month
    (SELECT COUNT(*) FROM clients 
     WHERE status = 'discharged' 
     AND discharge_date IS NOT NULL
     AND EXTRACT(MONTH FROM discharge_date) = EXTRACT(MONTH FROM CURRENT_DATE)
     AND EXTRACT(YEAR FROM discharge_date) = EXTRACT(YEAR FROM CURRENT_DATE))::bigint as this_month,
    -- Discharged this year
    (SELECT COUNT(*) FROM clients 
     WHERE status = 'discharged' 
     AND discharge_date IS NOT NULL
     AND EXTRACT(YEAR FROM discharge_date) = EXTRACT(YEAR FROM CURRENT_DATE))::bigint as this_year,
    -- Total discharged clients
    (SELECT COUNT(*) FROM clients WHERE status = 'discharged')::bigint as total_discharged,
    -- Planned discharges (those with a reason indicating planned)
    (SELECT COUNT(*) FROM clients 
     WHERE status = 'discharged' 
     AND reason_for_discharge IS NOT NULL 
     )::bigint as planned_discharges,
    -- Average days in care (from care_start_date to discharge_date)
    COALESCE((SELECT AVG(discharge_date - care_start_date)::bigint 
     FROM clients 
     WHERE status = 'discharged' 
     AND care_start_date IS NOT NULL 
     AND discharge_date IS NOT NULL), 0)::bigint as avg_days_in_care
`

type GetDashboardDischargeStatsRow struct {
	ThisMonth         int64 `json:"this_month"`
	ThisYear          int64 `json:"this_year"`
	TotalDischarged   int64 `json:"total_discharged"`
	PlannedDischarges int64 `json:"planned_discharges"`
	AvgDaysInCare     int64 `json:"avg_days_in_care"`
}

func (q *Queries) GetDashboardDischargeStats(ctx context.Context) (GetDashboardDischargeStatsRow, error) {
	row := q.db.QueryRow(ctx, getDashboardDischargeStats)
	var i GetDashboardDischargeStatsRow
	err := row.Scan(
		&i.ThisMonth,
		&i.ThisYear,
		&i.TotalDischarged,
		&i.PlannedDischarges,
		&i.AvgDaysInCare,
	)
	return i, err
}

const getDashboardOverviewStats = `-- name: GetDashboardOverviewStats :one

SELECT
    (SELECT COUNT(*) FROM clients WHERE status = 'in_care') as total_active_clients,
    (SELECT COUNT(*) FROM clients WHERE status = 'waiting_list') as waiting_list_count,
    (SELECT COUNT(*) FROM registration_forms WHERE status = 'pending' AND is_deleted = FALSE) as pending_registrations,
    (SELECT COUNT(*) FROM employees e 
     JOIN user_roles ur ON e.user_id = ur.user_id 
     JOIN roles r ON ur.role_id = r.id 
     WHERE r.name = 'coordinator' AND e.is_deleted = FALSE) as total_coordinators,
    (SELECT COUNT(*) FROM employees WHERE is_deleted = FALSE) as total_employees,
    (SELECT COUNT(*) FROM incidents WHERE (status = 'pending' OR status = 'under_investigation') AND is_deleted = FALSE) as open_incidents
`

type GetDashboardOverviewStatsRow struct {
	TotalActiveClients   int64 `json:"total_active_clients"`
	WaitingListCount     int64 `json:"waiting_list_count"`
	PendingRegistrations int64 `json:"pending_registrations"`
	TotalCoordinators    int64 `json:"total_coordinators"`
	TotalEmployees       int64 `json:"total_employees"`
	OpenIncidents        int64 `json:"open_incidents"`
}

// ============================================================
// Dashboard
// ============================================================
func (q *Queries) GetDashboardOverviewStats(ctx context.Context) (GetDashboardOverviewStatsRow, error) {
	row := q.db.QueryRow(ctx, getDashboardOverviewStats)
	var i GetDashboardOverviewStatsRow
	err := row.Scan(
		&i.TotalActiveClients,
		&i.WaitingListCount,
		&i.PendingRegistrations,
		&i.TotalCoordinators,
		&i.TotalEmployees,
		&i.OpenIncidents,
	)
	return i, err
}

const getEvaluationStats = `-- name: GetEvaluationStats :one
SELECT
    -- Total in-care clients that need evaluations
    (SELECT COUNT(*) FROM clients WHERE status = 'in_care')::bigint as total,
    -- Completed evaluations (submitted status)
    (SELECT COUNT(DISTINCT client_id) FROM client_evaluations WHERE status = 'submitted')::bigint as completed,
    -- Overdue evaluations (next_evaluation_date < today)
    (SELECT COUNT(*) FROM clients 
     WHERE status = 'in_care' 
     AND next_evaluation_date IS NOT NULL 
     AND next_evaluation_date < CURRENT_DATE)::bigint as overdue,
    -- Due soon (next_evaluation_date within 7 days)
    (SELECT COUNT(*) FROM clients 
     WHERE status = 'in_care' 
     AND next_evaluation_date IS NOT NULL 
     AND next_evaluation_date >= CURRENT_DATE
     AND next_evaluation_date <= (CURRENT_DATE + INTERVAL '7 days')::date)::bigint as due_soon
`

type GetEvaluationStatsRow struct {
	Total     int64 `json:"total"`
	Completed int64 `json:"completed"`
	Overdue   int64 `json:"overdue"`
	DueSoon   int64 `json:"due_soon"`
}

func (q *Queries) GetEvaluationStats(ctx context.Context) (GetEvaluationStatsRow, error) {
	row := q.db.QueryRow(ctx, getEvaluationStats)
	var i GetEvaluationStatsRow
	err := row.Scan(
		&i.Total,
		&i.Completed,
		&i.Overdue,
		&i.DueSoon,
	)
	return i, err
}

const getLocationCapacityList = `-- name: GetLocationCapacityList :many
SELECT
    l.id,
    l.name,
    l.capacity,
    l.occupied
FROM locations l
WHERE l.is_deleted = FALSE
`

type GetLocationCapacityListRow struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Capacity int32  `json:"capacity"`
	Occupied int32  `json:"occupied"`
}

func (q *Queries) GetLocationCapacityList(ctx context.Context) ([]GetLocationCapacityListRow, error) {
	rows, err := q.db.Query(ctx, getLocationCapacityList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLocationCapacityListRow{}
	for rows.Next() {
		var i GetLocationCapacityListRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Capacity,
			&i.Occupied,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocationCapacityTotals = `-- name: GetLocationCapacityTotals :one
SELECT
    COALESCE(SUM(capacity), 0)::bigint as total_capacity,
    COALESCE(SUM(occupied), 0)::bigint as total_occupied
FROM locations
WHERE is_deleted = FALSE
`

type GetLocationCapacityTotalsRow struct {
	TotalCapacity int64 `json:"total_capacity"`
	TotalOccupied int64 `json:"total_occupied"`
}

func (q *Queries) GetLocationCapacityTotals(ctx context.Context) (GetLocationCapacityTotalsRow, error) {
	row := q.db.QueryRow(ctx, getLocationCapacityTotals)
	var i GetLocationCapacityTotalsRow
	err := row.Scan(&i.TotalCapacity, &i.TotalOccupied)
	return i, err
}

const getPipelineStats = `-- name: GetPipelineStats :one
SELECT
    (SELECT COUNT(*) FROM registration_forms WHERE is_deleted = FALSE) as registrations,
    (SELECT COUNT(*) FROM intake_forms) as intakes,
    (SELECT COUNT(*) FROM clients WHERE status = 'waiting_list') as waiting_list,
    (SELECT COUNT(*) FROM clients WHERE status = 'in_care') as in_care,
    (SELECT COUNT(*) FROM clients WHERE status = 'discharged') as discharged
`

type GetPipelineStatsRow struct {
	Registrations int64 `json:"registrations"`
	Intakes       int64 `json:"intakes"`
	WaitingList   int64 `json:"waiting_list"`
	InCare        int64 `json:"in_care"`
	Discharged    int64 `json:"discharged"`
}

func (q *Queries) GetPipelineStats(ctx context.Context) (GetPipelineStatsRow, error) {
	row := q.db.QueryRow(ctx, getPipelineStats)
	var i GetPipelineStatsRow
	err := row.Scan(
		&i.Registrations,
		&i.Intakes,
		&i.WaitingList,
		&i.InCare,
		&i.Discharged,
	)
	return i, err
}

const getTodayAppointmentsForEmployee = `-- name: GetTodayAppointmentsForEmployee :many
SELECT
    a.id,
    a.title,
    a.type,
    a.start_time,
    a.end_time,
    a.location,
    -- Get client participant if exists
    COALESCE(
        (SELECT c.id FROM clients c 
         JOIN appointment_participants ap ON ap.participant_id = c.id 
         WHERE ap.appointment_id = a.id AND ap.participant_type = 'client' 
         LIMIT 1), 
        ''
    )::text as client_id,
    COALESCE(
        (SELECT CONCAT(c.first_name, ' ', c.last_name) FROM clients c 
         JOIN appointment_participants ap ON ap.participant_id = c.id 
         WHERE ap.appointment_id = a.id AND ap.participant_type = 'client' 
         LIMIT 1), 
        ''
    )::text as client_name
FROM appointments a
WHERE 
    DATE(a.start_time AT TIME ZONE 'UTC') = CURRENT_DATE
    AND (
        a.organizer_id = $1
        OR EXISTS (
            SELECT 1 FROM appointment_participants ap 
            WHERE ap.appointment_id = a.id 
            AND ap.participant_id = $1 
            AND ap.participant_type = 'employee'
        )
    )
ORDER BY a.start_time ASC
`

type GetTodayAppointmentsForEmployeeRow struct {
	ID         string              `json:"id"`
	Title      string              `json:"title"`
	Type       AppointmentTypeEnum `json:"type"`
	StartTime  pgtype.Timestamptz  `json:"start_time"`
	EndTime    pgtype.Timestamptz  `json:"end_time"`
	Location   *string             `json:"location"`
	ClientID   string              `json:"client_id"`
	ClientName string              `json:"client_name"`
}

func (q *Queries) GetTodayAppointmentsForEmployee(ctx context.Context, organizerID string) ([]GetTodayAppointmentsForEmployeeRow, error) {
	rows, err := q.db.Query(ctx, getTodayAppointmentsForEmployee, organizerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTodayAppointmentsForEmployeeRow{}
	for rows.Next() {
		var i GetTodayAppointmentsForEmployeeRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Type,
			&i.StartTime,
			&i.EndTime,
			&i.Location,
			&i.ClientID,
			&i.ClientName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
