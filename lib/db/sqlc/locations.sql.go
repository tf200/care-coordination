// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: locations.sql

package db

import (
	"context"
)

const createLocation = `-- name: CreateLocation :exec
INSERT INTO locations (
   id,
   name,
   postal_code,
   address,
   capacity,
   occupied
   )
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateLocationParams struct {
	ID         string `json:"id"`
	Name       string `json:"name"`
	PostalCode string `json:"postal_code"`
	Address    string `json:"address"`
	Capacity   int32  `json:"capacity"`
	Occupied   int32  `json:"occupied"`
}

func (q *Queries) CreateLocation(ctx context.Context, arg CreateLocationParams) error {
	_, err := q.db.Exec(ctx, createLocation,
		arg.ID,
		arg.Name,
		arg.PostalCode,
		arg.Address,
		arg.Capacity,
		arg.Occupied,
	)
	return err
}

const decrementLocationOccupied = `-- name: DecrementLocationOccupied :exec
UPDATE locations
SET occupied = occupied - 1, updated_at = NOW()
WHERE id = $1 AND occupied > 0
`

func (q *Queries) DecrementLocationOccupied(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, decrementLocationOccupied, id)
	return err
}

const incrementLocationOccupied = `-- name: IncrementLocationOccupied :exec
UPDATE locations
SET occupied = occupied + 1, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) IncrementLocationOccupied(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, incrementLocationOccupied, id)
	return err
}

const listLocations = `-- name: ListLocations :many
SELECT
    l.id,
    l.name,
    l.postal_code,
    l.address,
    l.capacity,
    l.occupied,
    COUNT(*) OVER() as total_count
FROM locations l
WHERE
    ($3::text IS NULL OR
     LOWER(l.name) LIKE LOWER('%' || $3::text || '%') OR
     LOWER(l.postal_code) LIKE LOWER('%' || $3::text || '%') OR
     LOWER(l.address) LIKE LOWER('%' || $3::text || '%'))
ORDER BY l.name
LIMIT $1 OFFSET $2
`

type ListLocationsParams struct {
	Limit  int32   `json:"limit"`
	Offset int32   `json:"offset"`
	Search *string `json:"search"`
}

type ListLocationsRow struct {
	ID         string `json:"id"`
	Name       string `json:"name"`
	PostalCode string `json:"postal_code"`
	Address    string `json:"address"`
	Capacity   int32  `json:"capacity"`
	Occupied   int32  `json:"occupied"`
	TotalCount int64  `json:"total_count"`
}

func (q *Queries) ListLocations(ctx context.Context, arg ListLocationsParams) ([]ListLocationsRow, error) {
	rows, err := q.db.Query(ctx, listLocations, arg.Limit, arg.Offset, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLocationsRow{}
	for rows.Next() {
		var i ListLocationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PostalCode,
			&i.Address,
			&i.Capacity,
			&i.Occupied,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteLocation = `-- name: SoftDeleteLocation :exec
UPDATE locations SET is_deleted = TRUE, updated_at = NOW() WHERE id = $1
`

func (q *Queries) SoftDeleteLocation(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, softDeleteLocation, id)
	return err
}

const updateLocation = `-- name: UpdateLocation :exec
UPDATE locations SET
    name = COALESCE($2, name),
    postal_code = COALESCE($3, postal_code),
    address = COALESCE($4, address),
    capacity = COALESCE($5, capacity),
    occupied = COALESCE($6, occupied),
    updated_at = NOW()
WHERE id = $1
`

type UpdateLocationParams struct {
	ID         string  `json:"id"`
	Name       *string `json:"name"`
	PostalCode *string `json:"postal_code"`
	Address    *string `json:"address"`
	Capacity   *int32  `json:"capacity"`
	Occupied   *int32  `json:"occupied"`
}

func (q *Queries) UpdateLocation(ctx context.Context, arg UpdateLocationParams) error {
	_, err := q.db.Exec(ctx, updateLocation,
		arg.ID,
		arg.Name,
		arg.PostalCode,
		arg.Address,
		arg.Capacity,
		arg.Occupied,
	)
	return err
}
