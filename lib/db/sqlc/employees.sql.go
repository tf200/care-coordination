// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: employees.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEmployee = `-- name: CreateEmployee :exec

INSERT INTO employees (
    id,
    user_id,
    first_name,
    last_name,
    bsn,
    date_of_birth,
    phone_number,
    gender,
    contract_hours,
    contract_type,
    location_id
) VALUES (
 $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
`

type CreateEmployeeParams struct {
	ID            string               `json:"id"`
	UserID        string               `json:"user_id"`
	FirstName     string               `json:"first_name"`
	LastName      string               `json:"last_name"`
	Bsn           string               `json:"bsn"`
	DateOfBirth   pgtype.Date          `json:"date_of_birth"`
	PhoneNumber   string               `json:"phone_number"`
	Gender        GenderEnum           `json:"gender"`
	ContractHours *int32               `json:"contract_hours"`
	ContractType  NullContractTypeEnum `json:"contract_type"`
	LocationID    string               `json:"location_id"`
}

// ============================================================
// Employees
// ============================================================
func (q *Queries) CreateEmployee(ctx context.Context, arg CreateEmployeeParams) error {
	_, err := q.db.Exec(ctx, createEmployee,
		arg.ID,
		arg.UserID,
		arg.FirstName,
		arg.LastName,
		arg.Bsn,
		arg.DateOfBirth,
		arg.PhoneNumber,
		arg.Gender,
		arg.ContractHours,
		arg.ContractType,
		arg.LocationID,
	)
	return err
}

const getEmployeeByID = `-- name: GetEmployeeByID :one
SELECT
    e.id,
    e.user_id,
    e.first_name,
    e.last_name,
    e.bsn,
    e.date_of_birth,
    e.phone_number,
    e.gender,
    e.contract_hours,
    e.contract_type,
    e.location_id,
    l.name as location_name,
    u.email,
    r.id as role_id,
    r.name as role_name,
    COALESCE(COUNT(DISTINCT c.id), 0) as client_count
FROM employees e
JOIN locations l ON e.location_id = l.id
JOIN users u ON e.user_id = u.id
LEFT JOIN user_roles ur ON e.user_id = ur.user_id
LEFT JOIN roles r ON ur.role_id = r.id
LEFT JOIN clients c ON c.coordinator_id = e.id
WHERE e.id = $1
GROUP BY e.id, e.user_id, e.first_name, e.last_name, e.bsn, e.date_of_birth, 
         e.phone_number, e.gender, e.contract_hours, e.contract_type, e.location_id,
         l.name, u.email, r.id, r.name
LIMIT 1
`

type GetEmployeeByIDRow struct {
	ID            string               `json:"id"`
	UserID        string               `json:"user_id"`
	FirstName     string               `json:"first_name"`
	LastName      string               `json:"last_name"`
	Bsn           string               `json:"bsn"`
	DateOfBirth   pgtype.Date          `json:"date_of_birth"`
	PhoneNumber   string               `json:"phone_number"`
	Gender        GenderEnum           `json:"gender"`
	ContractHours *int32               `json:"contract_hours"`
	ContractType  NullContractTypeEnum `json:"contract_type"`
	LocationID    string               `json:"location_id"`
	LocationName  string               `json:"location_name"`
	Email         string               `json:"email"`
	RoleID        *string              `json:"role_id"`
	RoleName      *string              `json:"role_name"`
	ClientCount   interface{}          `json:"client_count"`
}

func (q *Queries) GetEmployeeByID(ctx context.Context, id string) (GetEmployeeByIDRow, error) {
	row := q.db.QueryRow(ctx, getEmployeeByID, id)
	var i GetEmployeeByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.Bsn,
		&i.DateOfBirth,
		&i.PhoneNumber,
		&i.Gender,
		&i.ContractHours,
		&i.ContractType,
		&i.LocationID,
		&i.LocationName,
		&i.Email,
		&i.RoleID,
		&i.RoleName,
		&i.ClientCount,
	)
	return i, err
}

const getEmployeeByUserID = `-- name: GetEmployeeByUserID :one
SELECT e.id, e.user_id, e.first_name, e.last_name, e.bsn, e.date_of_birth, e.phone_number, e.gender, e.contract_hours, e.contract_type, e.location_id, e.created_at, e.updated_at, u.email,
       r.id as role_id,
       r.name as role_name,
       l.name as location_name
FROM employees e
JOIN users u ON e.user_id = u.id
LEFT JOIN user_roles ur ON e.user_id = ur.user_id
LEFT JOIN roles r ON ur.role_id = r.id
LEFT JOIN locations l ON e.location_id = l.id
WHERE e.user_id = $1 LIMIT 1
`

type GetEmployeeByUserIDRow struct {
	ID            string               `json:"id"`
	UserID        string               `json:"user_id"`
	FirstName     string               `json:"first_name"`
	LastName      string               `json:"last_name"`
	Bsn           string               `json:"bsn"`
	DateOfBirth   pgtype.Date          `json:"date_of_birth"`
	PhoneNumber   string               `json:"phone_number"`
	Gender        GenderEnum           `json:"gender"`
	ContractHours *int32               `json:"contract_hours"`
	ContractType  NullContractTypeEnum `json:"contract_type"`
	LocationID    string               `json:"location_id"`
	CreatedAt     pgtype.Timestamp     `json:"created_at"`
	UpdatedAt     pgtype.Timestamp     `json:"updated_at"`
	Email         string               `json:"email"`
	RoleID        *string              `json:"role_id"`
	RoleName      *string              `json:"role_name"`
	LocationName  *string              `json:"location_name"`
}

func (q *Queries) GetEmployeeByUserID(ctx context.Context, userID string) (GetEmployeeByUserIDRow, error) {
	row := q.db.QueryRow(ctx, getEmployeeByUserID, userID)
	var i GetEmployeeByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.Bsn,
		&i.DateOfBirth,
		&i.PhoneNumber,
		&i.Gender,
		&i.ContractHours,
		&i.ContractType,
		&i.LocationID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.RoleID,
		&i.RoleName,
		&i.LocationName,
	)
	return i, err
}

const listEmployees = `-- name: ListEmployees :many
SELECT
    e.id,
    e.user_id,
    e.first_name,
    e.last_name,
    e.bsn,
    e.date_of_birth,
    e.phone_number,
    e.gender,
    e.contract_hours,
    e.contract_type,
    e.location_id,
    l.name as location_name,
    u.email,
    COALESCE(COUNT(DISTINCT c.id), 0) as client_count,
    COUNT(*) OVER() as total_count
FROM employees e
JOIN locations l ON e.location_id = l.id
JOIN users u ON e.user_id = u.id
LEFT JOIN clients c ON c.coordinator_id = e.id
WHERE
e.is_deleted = false AND
(
  $3::text IS NULL OR
  e.first_name ILIKE '%' || $3::text || '%' OR
  e.last_name ILIKE '%' || $3::text || '%' OR
  CONCAT(e.first_name, ' ', e.last_name) ILIKE '%' || $3::text || '%'
)
GROUP BY e.id, e.user_id, e.first_name, e.last_name, e.bsn, e.date_of_birth, 
         e.phone_number, e.gender, e.contract_hours, e.contract_type, e.location_id,
         l.name, u.email
ORDER BY e.first_name, e.last_name
LIMIT $1 OFFSET $2
`

type ListEmployeesParams struct {
	Limit  int32   `json:"limit"`
	Offset int32   `json:"offset"`
	Search *string `json:"search"`
}

type ListEmployeesRow struct {
	ID            string               `json:"id"`
	UserID        string               `json:"user_id"`
	FirstName     string               `json:"first_name"`
	LastName      string               `json:"last_name"`
	Bsn           string               `json:"bsn"`
	DateOfBirth   pgtype.Date          `json:"date_of_birth"`
	PhoneNumber   string               `json:"phone_number"`
	Gender        GenderEnum           `json:"gender"`
	ContractHours *int32               `json:"contract_hours"`
	ContractType  NullContractTypeEnum `json:"contract_type"`
	LocationID    string               `json:"location_id"`
	LocationName  string               `json:"location_name"`
	Email         string               `json:"email"`
	ClientCount   interface{}          `json:"client_count"`
	TotalCount    int64                `json:"total_count"`
}

func (q *Queries) ListEmployees(ctx context.Context, arg ListEmployeesParams) ([]ListEmployeesRow, error) {
	rows, err := q.db.Query(ctx, listEmployees, arg.Limit, arg.Offset, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEmployeesRow{}
	for rows.Next() {
		var i ListEmployeesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.Bsn,
			&i.DateOfBirth,
			&i.PhoneNumber,
			&i.Gender,
			&i.ContractHours,
			&i.ContractType,
			&i.LocationID,
			&i.LocationName,
			&i.Email,
			&i.ClientCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteEmployee = `-- name: SoftDeleteEmployee :exec
UPDATE employees SET is_deleted = true, updated_at = now() WHERE id = $1
`

func (q *Queries) SoftDeleteEmployee(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, softDeleteEmployee, id)
	return err
}

const updateEmployee = `-- name: UpdateEmployee :exec
UPDATE employees SET
    first_name = COALESCE($2, first_name),
    last_name = COALESCE($3, last_name),
    bsn = COALESCE($4, bsn),
    date_of_birth = COALESCE($5, date_of_birth),
    phone_number = COALESCE($6, phone_number),
    gender = COALESCE($7, gender),
    contract_hours = COALESCE($8, contract_hours),
    contract_type = COALESCE($9, contract_type),
    location_id = COALESCE($10, location_id),
    updated_at = now()
WHERE id = $1
`

type UpdateEmployeeParams struct {
	ID            string               `json:"id"`
	FirstName     *string              `json:"first_name"`
	LastName      *string              `json:"last_name"`
	Bsn           *string              `json:"bsn"`
	DateOfBirth   pgtype.Date          `json:"date_of_birth"`
	PhoneNumber   *string              `json:"phone_number"`
	Gender        NullGenderEnum       `json:"gender"`
	ContractHours *int32               `json:"contract_hours"`
	ContractType  NullContractTypeEnum `json:"contract_type"`
	LocationID    *string              `json:"location_id"`
}

func (q *Queries) UpdateEmployee(ctx context.Context, arg UpdateEmployeeParams) error {
	_, err := q.db.Exec(ctx, updateEmployee,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Bsn,
		arg.DateOfBirth,
		arg.PhoneNumber,
		arg.Gender,
		arg.ContractHours,
		arg.ContractType,
		arg.LocationID,
	)
	return err
}
