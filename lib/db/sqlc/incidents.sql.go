// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: incidents.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createIncident = `-- name: CreateIncident :exec
INSERT INTO incidents (
    id,
    client_id,
    incident_date,
    incident_time,
    incident_type,
    incident_severity,
    location_id,
    coordinator_id,
    incident_description,
    action_taken,
    other_parties,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
`

type CreateIncidentParams struct {
	ID                  string               `json:"id"`
	ClientID            string               `json:"client_id"`
	IncidentDate        pgtype.Date          `json:"incident_date"`
	IncidentTime        pgtype.Time          `json:"incident_time"`
	IncidentType        IncidentTypeEnum     `json:"incident_type"`
	IncidentSeverity    IncidentSeverityEnum `json:"incident_severity"`
	LocationID          string               `json:"location_id"`
	CoordinatorID       string               `json:"coordinator_id"`
	IncidentDescription string               `json:"incident_description"`
	ActionTaken         string               `json:"action_taken"`
	OtherParties        *string              `json:"other_parties"`
	Status              IncidentStatusEnum   `json:"status"`
}

func (q *Queries) CreateIncident(ctx context.Context, arg CreateIncidentParams) error {
	_, err := q.db.Exec(ctx, createIncident,
		arg.ID,
		arg.ClientID,
		arg.IncidentDate,
		arg.IncidentTime,
		arg.IncidentType,
		arg.IncidentSeverity,
		arg.LocationID,
		arg.CoordinatorID,
		arg.IncidentDescription,
		arg.ActionTaken,
		arg.OtherParties,
		arg.Status,
	)
	return err
}

const getIncident = `-- name: GetIncident :one
SELECT i.id, i.client_id, i.incident_date, i.incident_time, i.incident_type, i.incident_severity, i.location_id, i.coordinator_id, i.incident_description, i.action_taken, i.other_parties, i.status, i.created_at, i.updated_at, i.is_deleted,
       c.first_name AS client_first_name,
       c.last_name AS client_last_name,
       l.name AS location_name,
       e.first_name AS coordinator_first_name,
       e.last_name AS coordinator_last_name
FROM incidents i
JOIN clients c ON i.client_id = c.id
JOIN locations l ON i.location_id = l.id
JOIN employees e ON i.coordinator_id = e.id
WHERE i.id = $1 AND i.is_deleted = FALSE
`

type GetIncidentRow struct {
	ID                   string               `json:"id"`
	ClientID             string               `json:"client_id"`
	IncidentDate         pgtype.Date          `json:"incident_date"`
	IncidentTime         pgtype.Time          `json:"incident_time"`
	IncidentType         IncidentTypeEnum     `json:"incident_type"`
	IncidentSeverity     IncidentSeverityEnum `json:"incident_severity"`
	LocationID           string               `json:"location_id"`
	CoordinatorID        string               `json:"coordinator_id"`
	IncidentDescription  string               `json:"incident_description"`
	ActionTaken          string               `json:"action_taken"`
	OtherParties         *string              `json:"other_parties"`
	Status               IncidentStatusEnum   `json:"status"`
	CreatedAt            pgtype.Timestamp     `json:"created_at"`
	UpdatedAt            pgtype.Timestamp     `json:"updated_at"`
	IsDeleted            *bool                `json:"is_deleted"`
	ClientFirstName      string               `json:"client_first_name"`
	ClientLastName       string               `json:"client_last_name"`
	LocationName         string               `json:"location_name"`
	CoordinatorFirstName string               `json:"coordinator_first_name"`
	CoordinatorLastName  string               `json:"coordinator_last_name"`
}

func (q *Queries) GetIncident(ctx context.Context, id string) (GetIncidentRow, error) {
	row := q.db.QueryRow(ctx, getIncident, id)
	var i GetIncidentRow
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.IncidentDate,
		&i.IncidentTime,
		&i.IncidentType,
		&i.IncidentSeverity,
		&i.LocationID,
		&i.CoordinatorID,
		&i.IncidentDescription,
		&i.ActionTaken,
		&i.OtherParties,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsDeleted,
		&i.ClientFirstName,
		&i.ClientLastName,
		&i.LocationName,
		&i.CoordinatorFirstName,
		&i.CoordinatorLastName,
	)
	return i, err
}

const getIncidentStats = `-- name: GetIncidentStats :one
SELECT 
    COUNT(*) as total_count,
    -- Counts by severity
    COUNT(*) FILTER (WHERE incident_severity = 'minor') as minor_count,
    COUNT(*) FILTER (WHERE incident_severity = 'moderate') as moderate_count,
    COUNT(*) FILTER (WHERE incident_severity = 'severe') as severe_count,
    -- Counts by status
    COUNT(*) FILTER (WHERE status = 'pending') as pending_count,
    COUNT(*) FILTER (WHERE status = 'under_investigation') as under_investigation_count,
    COUNT(*) FILTER (WHERE status = 'completed') as completed_count,
    -- Counts by type
    COUNT(*) FILTER (WHERE incident_type = 'aggression') as aggression_count,
    COUNT(*) FILTER (WHERE incident_type = 'medical_emergency') as medical_emergency_count,
    COUNT(*) FILTER (WHERE incident_type = 'safety_concern') as safety_concern_count,
    COUNT(*) FILTER (WHERE incident_type = 'unwanted_behavior') as unwanted_behavior_count,
    COUNT(*) FILTER (WHERE incident_type = 'other') as other_type_count
FROM incidents
WHERE is_deleted = FALSE
`

type GetIncidentStatsRow struct {
	TotalCount              int64 `json:"total_count"`
	MinorCount              int64 `json:"minor_count"`
	ModerateCount           int64 `json:"moderate_count"`
	SevereCount             int64 `json:"severe_count"`
	PendingCount            int64 `json:"pending_count"`
	UnderInvestigationCount int64 `json:"under_investigation_count"`
	CompletedCount          int64 `json:"completed_count"`
	AggressionCount         int64 `json:"aggression_count"`
	MedicalEmergencyCount   int64 `json:"medical_emergency_count"`
	SafetyConcernCount      int64 `json:"safety_concern_count"`
	UnwantedBehaviorCount   int64 `json:"unwanted_behavior_count"`
	OtherTypeCount          int64 `json:"other_type_count"`
}

func (q *Queries) GetIncidentStats(ctx context.Context) (GetIncidentStatsRow, error) {
	row := q.db.QueryRow(ctx, getIncidentStats)
	var i GetIncidentStatsRow
	err := row.Scan(
		&i.TotalCount,
		&i.MinorCount,
		&i.ModerateCount,
		&i.SevereCount,
		&i.PendingCount,
		&i.UnderInvestigationCount,
		&i.CompletedCount,
		&i.AggressionCount,
		&i.MedicalEmergencyCount,
		&i.SafetyConcernCount,
		&i.UnwantedBehaviorCount,
		&i.OtherTypeCount,
	)
	return i, err
}

const listIncidents = `-- name: ListIncidents :many
SELECT i.id, i.client_id, i.incident_date, i.incident_time, i.incident_type, i.incident_severity, i.location_id, i.coordinator_id, i.incident_description, i.action_taken, i.other_parties, i.status, i.created_at, i.updated_at, i.is_deleted,
       c.first_name AS client_first_name,
       c.last_name AS client_last_name,
       l.name AS location_name,
       e.first_name AS coordinator_first_name,
       e.last_name AS coordinator_last_name,
       COUNT(*) OVER() as total_count
FROM incidents i
JOIN clients c ON i.client_id = c.id
JOIN locations l ON i.location_id = l.id
JOIN employees e ON i.coordinator_id = e.id
WHERE i.is_deleted = FALSE
AND (
  $3::text IS NULL OR
  c.first_name ILIKE '%' || $3::text || '%' OR
  c.last_name ILIKE '%' || $3::text || '%' OR
  CONCAT(c.first_name, ' ', c.last_name) ILIKE '%' || $3::text || '%'
)
ORDER BY i.incident_date DESC
LIMIT $1 OFFSET $2
`

type ListIncidentsParams struct {
	Limit  int32   `json:"limit"`
	Offset int32   `json:"offset"`
	Search *string `json:"search"`
}

type ListIncidentsRow struct {
	ID                   string               `json:"id"`
	ClientID             string               `json:"client_id"`
	IncidentDate         pgtype.Date          `json:"incident_date"`
	IncidentTime         pgtype.Time          `json:"incident_time"`
	IncidentType         IncidentTypeEnum     `json:"incident_type"`
	IncidentSeverity     IncidentSeverityEnum `json:"incident_severity"`
	LocationID           string               `json:"location_id"`
	CoordinatorID        string               `json:"coordinator_id"`
	IncidentDescription  string               `json:"incident_description"`
	ActionTaken          string               `json:"action_taken"`
	OtherParties         *string              `json:"other_parties"`
	Status               IncidentStatusEnum   `json:"status"`
	CreatedAt            pgtype.Timestamp     `json:"created_at"`
	UpdatedAt            pgtype.Timestamp     `json:"updated_at"`
	IsDeleted            *bool                `json:"is_deleted"`
	ClientFirstName      string               `json:"client_first_name"`
	ClientLastName       string               `json:"client_last_name"`
	LocationName         string               `json:"location_name"`
	CoordinatorFirstName string               `json:"coordinator_first_name"`
	CoordinatorLastName  string               `json:"coordinator_last_name"`
	TotalCount           int64                `json:"total_count"`
}

func (q *Queries) ListIncidents(ctx context.Context, arg ListIncidentsParams) ([]ListIncidentsRow, error) {
	rows, err := q.db.Query(ctx, listIncidents, arg.Limit, arg.Offset, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListIncidentsRow{}
	for rows.Next() {
		var i ListIncidentsRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.IncidentDate,
			&i.IncidentTime,
			&i.IncidentType,
			&i.IncidentSeverity,
			&i.LocationID,
			&i.CoordinatorID,
			&i.IncidentDescription,
			&i.ActionTaken,
			&i.OtherParties,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsDeleted,
			&i.ClientFirstName,
			&i.ClientLastName,
			&i.LocationName,
			&i.CoordinatorFirstName,
			&i.CoordinatorLastName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteIncident = `-- name: SoftDeleteIncident :exec
UPDATE incidents
SET 
    is_deleted = TRUE,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) SoftDeleteIncident(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, softDeleteIncident, id)
	return err
}

const updateIncident = `-- name: UpdateIncident :exec
UPDATE incidents
SET 
    incident_date = COALESCE($2::DATE, incident_date),
    incident_time = COALESCE($3::TIME, incident_time),
    incident_type = COALESCE($4::incident_type_enum, incident_type),
    incident_severity = COALESCE($5::incident_severity_enum, incident_severity),
    location_id = COALESCE($6::TEXT, location_id),
    coordinator_id = COALESCE($7::TEXT, coordinator_id),
    incident_description = COALESCE($8::TEXT, incident_description),
    action_taken = COALESCE($9::TEXT, action_taken),
    other_parties = CASE 
        WHEN $10::TEXT = '' THEN NULL
        ELSE COALESCE($10::TEXT, other_parties)
    END,
    status = COALESCE($11::incident_status_enum, status),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND is_deleted = FALSE
`

type UpdateIncidentParams struct {
	ID                  string                   `json:"id"`
	IncidentDate        pgtype.Date              `json:"incident_date"`
	IncidentTime        pgtype.Time              `json:"incident_time"`
	IncidentType        NullIncidentTypeEnum     `json:"incident_type"`
	IncidentSeverity    NullIncidentSeverityEnum `json:"incident_severity"`
	LocationID          *string                  `json:"location_id"`
	CoordinatorID       *string                  `json:"coordinator_id"`
	IncidentDescription *string                  `json:"incident_description"`
	ActionTaken         *string                  `json:"action_taken"`
	OtherParties        *string                  `json:"other_parties"`
	Status              NullIncidentStatusEnum   `json:"status"`
}

func (q *Queries) UpdateIncident(ctx context.Context, arg UpdateIncidentParams) error {
	_, err := q.db.Exec(ctx, updateIncident,
		arg.ID,
		arg.IncidentDate,
		arg.IncidentTime,
		arg.IncidentType,
		arg.IncidentSeverity,
		arg.LocationID,
		arg.CoordinatorID,
		arg.IncidentDescription,
		arg.ActionTaken,
		arg.OtherParties,
		arg.Status,
	)
	return err
}
