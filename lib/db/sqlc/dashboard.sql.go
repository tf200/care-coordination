// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: dashboard.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCareTypeDistribution = `-- name: GetCareTypeDistribution :one
SELECT
    (SELECT COUNT(*) FROM clients WHERE status = 'in_care' AND care_type = 'protected_living') as protected_living,
    (SELECT COUNT(*) FROM clients WHERE status = 'in_care' AND care_type = 'semi_independent_living') as semi_independent_living,
    (SELECT COUNT(*) FROM clients WHERE status = 'in_care' AND care_type = 'independent_assisted_living') as independent_assisted_living,
    (SELECT COUNT(*) FROM clients WHERE status = 'in_care' AND care_type = 'ambulatory_care') as ambulatory_care,
    (SELECT COUNT(*) FROM clients WHERE status = 'in_care') as total
`

type GetCareTypeDistributionRow struct {
	ProtectedLiving           int64 `json:"protected_living"`
	SemiIndependentLiving     int64 `json:"semi_independent_living"`
	IndependentAssistedLiving int64 `json:"independent_assisted_living"`
	AmbulatoryCare            int64 `json:"ambulatory_care"`
	Total                     int64 `json:"total"`
}

func (q *Queries) GetCareTypeDistribution(ctx context.Context) (GetCareTypeDistributionRow, error) {
	row := q.db.QueryRow(ctx, getCareTypeDistribution)
	var i GetCareTypeDistributionRow
	err := row.Scan(
		&i.ProtectedLiving,
		&i.SemiIndependentLiving,
		&i.IndependentAssistedLiving,
		&i.AmbulatoryCare,
		&i.Total,
	)
	return i, err
}

const getCriticalAlertsData = `-- name: GetCriticalAlertsData :one
SELECT
    -- Overdue evaluations (next_evaluation_date < today)
    (SELECT COUNT(*) FROM clients 
     WHERE status = 'in_care' 
     AND next_evaluation_date IS NOT NULL 
     AND next_evaluation_date < CURRENT_DATE) as overdue_evaluations,
    
    -- Care end date approaching (within 30 days)
    (SELECT COUNT(*) FROM clients 
     WHERE status = 'in_care' 
     AND care_end_date IS NOT NULL 
     AND care_end_date <= (CURRENT_DATE + INTERVAL '30 days')::date
     AND care_end_date >= CURRENT_DATE) as care_ending_soon,
    
    -- Open incidents (pending or under_investigation)
    (SELECT COUNT(*) FROM incidents 
     WHERE (status = 'pending' OR status = 'under_investigation') 
     AND is_deleted = FALSE) as open_incidents,
    
    -- Severe incidents count (for description)
    (SELECT COUNT(*) FROM incidents 
     WHERE (status = 'pending' OR status = 'under_investigation') 
     AND incident_severity = 'severe'
     AND is_deleted = FALSE) as severe_incidents,
    
    -- Moderate incidents count (for description)
    (SELECT COUNT(*) FROM incidents 
     WHERE (status = 'pending' OR status = 'under_investigation') 
     AND incident_severity = 'moderate'
     AND is_deleted = FALSE) as moderate_incidents,
    
    -- High priority waiting list
    (SELECT COUNT(*) FROM clients 
     WHERE status = 'waiting_list' 
     AND waiting_list_priority = 'high') as high_priority_waiting,
    
    -- Pending location transfers
    (SELECT COUNT(*) FROM client_location_transfers 
     WHERE status = 'pending') as pending_transfers
`

type GetCriticalAlertsDataRow struct {
	OverdueEvaluations  int64 `json:"overdue_evaluations"`
	CareEndingSoon      int64 `json:"care_ending_soon"`
	OpenIncidents       int64 `json:"open_incidents"`
	SevereIncidents     int64 `json:"severe_incidents"`
	ModerateIncidents   int64 `json:"moderate_incidents"`
	HighPriorityWaiting int64 `json:"high_priority_waiting"`
	PendingTransfers    int64 `json:"pending_transfers"`
}

func (q *Queries) GetCriticalAlertsData(ctx context.Context) (GetCriticalAlertsDataRow, error) {
	row := q.db.QueryRow(ctx, getCriticalAlertsData)
	var i GetCriticalAlertsDataRow
	err := row.Scan(
		&i.OverdueEvaluations,
		&i.CareEndingSoon,
		&i.OpenIncidents,
		&i.SevereIncidents,
		&i.ModerateIncidents,
		&i.HighPriorityWaiting,
		&i.PendingTransfers,
	)
	return i, err
}

const getDashboardDischargeStats = `-- name: GetDashboardDischargeStats :one
SELECT
    -- Discharged this month
    (SELECT COUNT(*) FROM clients 
     WHERE status = 'discharged' 
     AND discharge_date IS NOT NULL
     AND EXTRACT(MONTH FROM discharge_date) = EXTRACT(MONTH FROM CURRENT_DATE)
     AND EXTRACT(YEAR FROM discharge_date) = EXTRACT(YEAR FROM CURRENT_DATE))::bigint as this_month,
    -- Discharged this year
    (SELECT COUNT(*) FROM clients 
     WHERE status = 'discharged' 
     AND discharge_date IS NOT NULL
     AND EXTRACT(YEAR FROM discharge_date) = EXTRACT(YEAR FROM CURRENT_DATE))::bigint as this_year,
    -- Total discharged clients
    (SELECT COUNT(*) FROM clients WHERE status = 'discharged')::bigint as total_discharged,
    -- Planned discharges (those with a reason indicating planned)
    (SELECT COUNT(*) FROM clients 
     WHERE status = 'discharged' 
     AND reason_for_discharge IS NOT NULL 
     AND reason_for_discharge != '')::bigint as planned_discharges,
    -- Average days in care (from care_start_date to discharge_date)
    COALESCE((SELECT AVG(EXTRACT(DAY FROM (discharge_date - care_start_date)))::bigint 
     FROM clients 
     WHERE status = 'discharged' 
     AND care_start_date IS NOT NULL 
     AND discharge_date IS NOT NULL), 0)::bigint as avg_days_in_care
`

type GetDashboardDischargeStatsRow struct {
	ThisMonth         int64 `json:"this_month"`
	ThisYear          int64 `json:"this_year"`
	TotalDischarged   int64 `json:"total_discharged"`
	PlannedDischarges int64 `json:"planned_discharges"`
	AvgDaysInCare     int64 `json:"avg_days_in_care"`
}

func (q *Queries) GetDashboardDischargeStats(ctx context.Context) (GetDashboardDischargeStatsRow, error) {
	row := q.db.QueryRow(ctx, getDashboardDischargeStats)
	var i GetDashboardDischargeStatsRow
	err := row.Scan(
		&i.ThisMonth,
		&i.ThisYear,
		&i.TotalDischarged,
		&i.PlannedDischarges,
		&i.AvgDaysInCare,
	)
	return i, err
}

const getDashboardOverviewStats = `-- name: GetDashboardOverviewStats :one

SELECT
    (SELECT COUNT(*) FROM clients WHERE status = 'in_care') as total_active_clients,
    (SELECT COUNT(*) FROM clients WHERE status = 'waiting_list') as waiting_list_count,
    (SELECT COUNT(*) FROM registration_forms WHERE status = 'pending' AND is_deleted = FALSE) as pending_registrations,
    (SELECT COUNT(*) FROM employees e 
     JOIN user_roles ur ON e.user_id = ur.user_id 
     JOIN roles r ON ur.role_id = r.id 
     WHERE r.name = 'coordinator' AND e.is_deleted = FALSE) as total_coordinators,
    (SELECT COUNT(*) FROM employees WHERE is_deleted = FALSE) as total_employees,
    (SELECT COUNT(*) FROM incidents WHERE (status = 'pending' OR status = 'under_investigation') AND is_deleted = FALSE) as open_incidents
`

type GetDashboardOverviewStatsRow struct {
	TotalActiveClients   int64 `json:"total_active_clients"`
	WaitingListCount     int64 `json:"waiting_list_count"`
	PendingRegistrations int64 `json:"pending_registrations"`
	TotalCoordinators    int64 `json:"total_coordinators"`
	TotalEmployees       int64 `json:"total_employees"`
	OpenIncidents        int64 `json:"open_incidents"`
}

// ============================================================
// Dashboard
// ============================================================
func (q *Queries) GetDashboardOverviewStats(ctx context.Context) (GetDashboardOverviewStatsRow, error) {
	row := q.db.QueryRow(ctx, getDashboardOverviewStats)
	var i GetDashboardOverviewStatsRow
	err := row.Scan(
		&i.TotalActiveClients,
		&i.WaitingListCount,
		&i.PendingRegistrations,
		&i.TotalCoordinators,
		&i.TotalEmployees,
		&i.OpenIncidents,
	)
	return i, err
}

const getEvaluationStats = `-- name: GetEvaluationStats :one
SELECT
    -- Total in-care clients that need evaluations
    (SELECT COUNT(*) FROM clients WHERE status = 'in_care')::bigint as total,
    -- Completed evaluations (submitted status)
    (SELECT COUNT(DISTINCT client_id) FROM client_evaluations WHERE status = 'submitted')::bigint as completed,
    -- Overdue evaluations (next_evaluation_date < today)
    (SELECT COUNT(*) FROM clients 
     WHERE status = 'in_care' 
     AND next_evaluation_date IS NOT NULL 
     AND next_evaluation_date < CURRENT_DATE)::bigint as overdue,
    -- Due soon (next_evaluation_date within 7 days)
    (SELECT COUNT(*) FROM clients 
     WHERE status = 'in_care' 
     AND next_evaluation_date IS NOT NULL 
     AND next_evaluation_date >= CURRENT_DATE
     AND next_evaluation_date <= (CURRENT_DATE + INTERVAL '7 days')::date)::bigint as due_soon
`

type GetEvaluationStatsRow struct {
	Total     int64 `json:"total"`
	Completed int64 `json:"completed"`
	Overdue   int64 `json:"overdue"`
	DueSoon   int64 `json:"due_soon"`
}

func (q *Queries) GetEvaluationStats(ctx context.Context) (GetEvaluationStatsRow, error) {
	row := q.db.QueryRow(ctx, getEvaluationStats)
	var i GetEvaluationStatsRow
	err := row.Scan(
		&i.Total,
		&i.Completed,
		&i.Overdue,
		&i.DueSoon,
	)
	return i, err
}

const getLocationCapacityList = `-- name: GetLocationCapacityList :many
SELECT
    l.id,
    l.name,
    l.capacity,
    l.occupied
FROM locations l
WHERE l.is_deleted = FALSE
`

type GetLocationCapacityListRow struct {
	ID       string `json:"id"`
	Name     string `json:"name"`
	Capacity int32  `json:"capacity"`
	Occupied int32  `json:"occupied"`
}

func (q *Queries) GetLocationCapacityList(ctx context.Context) ([]GetLocationCapacityListRow, error) {
	rows, err := q.db.Query(ctx, getLocationCapacityList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLocationCapacityListRow{}
	for rows.Next() {
		var i GetLocationCapacityListRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Capacity,
			&i.Occupied,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLocationCapacityTotals = `-- name: GetLocationCapacityTotals :one
SELECT
    COALESCE(SUM(capacity), 0)::bigint as total_capacity,
    COALESCE(SUM(occupied), 0)::bigint as total_occupied
FROM locations
WHERE is_deleted = FALSE
`

type GetLocationCapacityTotalsRow struct {
	TotalCapacity int64 `json:"total_capacity"`
	TotalOccupied int64 `json:"total_occupied"`
}

func (q *Queries) GetLocationCapacityTotals(ctx context.Context) (GetLocationCapacityTotalsRow, error) {
	row := q.db.QueryRow(ctx, getLocationCapacityTotals)
	var i GetLocationCapacityTotalsRow
	err := row.Scan(&i.TotalCapacity, &i.TotalOccupied)
	return i, err
}

const getPipelineStats = `-- name: GetPipelineStats :one
SELECT
    (SELECT COUNT(*) FROM registration_forms WHERE is_deleted = FALSE) as registrations,
    (SELECT COUNT(*) FROM intake_forms) as intakes,
    (SELECT COUNT(*) FROM clients WHERE status = 'waiting_list') as waiting_list,
    (SELECT COUNT(*) FROM clients WHERE status = 'in_care') as in_care,
    (SELECT COUNT(*) FROM clients WHERE status = 'discharged') as discharged
`

type GetPipelineStatsRow struct {
	Registrations int64 `json:"registrations"`
	Intakes       int64 `json:"intakes"`
	WaitingList   int64 `json:"waiting_list"`
	InCare        int64 `json:"in_care"`
	Discharged    int64 `json:"discharged"`
}

func (q *Queries) GetPipelineStats(ctx context.Context) (GetPipelineStatsRow, error) {
	row := q.db.QueryRow(ctx, getPipelineStats)
	var i GetPipelineStatsRow
	err := row.Scan(
		&i.Registrations,
		&i.Intakes,
		&i.WaitingList,
		&i.InCare,
		&i.Discharged,
	)
	return i, err
}

const getTodayAppointmentsForEmployee = `-- name: GetTodayAppointmentsForEmployee :many
SELECT
    a.id,
    a.title,
    a.type,
    a.start_time,
    a.end_time,
    a.location,
    -- Get client participant if exists
    COALESCE(
        (SELECT c.id FROM clients c 
         JOIN appointment_participants ap ON ap.participant_id = c.id 
         WHERE ap.appointment_id = a.id AND ap.participant_type = 'client' 
         LIMIT 1), 
        ''
    )::text as client_id,
    COALESCE(
        (SELECT CONCAT(c.first_name, ' ', c.last_name) FROM clients c 
         JOIN appointment_participants ap ON ap.participant_id = c.id 
         WHERE ap.appointment_id = a.id AND ap.participant_type = 'client' 
         LIMIT 1), 
        ''
    )::text as client_name
FROM appointments a
WHERE 
    DATE(a.start_time AT TIME ZONE 'UTC') = CURRENT_DATE
    AND (
        a.organizer_id = $1
        OR EXISTS (
            SELECT 1 FROM appointment_participants ap 
            WHERE ap.appointment_id = a.id 
            AND ap.participant_id = $1 
            AND ap.participant_type = 'employee'
        )
    )
ORDER BY a.start_time ASC
`

type GetTodayAppointmentsForEmployeeRow struct {
	ID         string              `json:"id"`
	Title      string              `json:"title"`
	Type       AppointmentTypeEnum `json:"type"`
	StartTime  pgtype.Timestamptz  `json:"start_time"`
	EndTime    pgtype.Timestamptz  `json:"end_time"`
	Location   *string             `json:"location"`
	ClientID   string              `json:"client_id"`
	ClientName string              `json:"client_name"`
}

func (q *Queries) GetTodayAppointmentsForEmployee(ctx context.Context, organizerID string) ([]GetTodayAppointmentsForEmployeeRow, error) {
	rows, err := q.db.Query(ctx, getTodayAppointmentsForEmployee, organizerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTodayAppointmentsForEmployeeRow{}
	for rows.Next() {
		var i GetTodayAppointmentsForEmployeeRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Type,
			&i.StartTime,
			&i.EndTime,
			&i.Location,
			&i.ClientID,
			&i.ClientName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
