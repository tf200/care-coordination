// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: client_evaluations.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createClientEvaluation = `-- name: CreateClientEvaluation :one
INSERT INTO client_evaluations (
    id,
    client_id,
    coordinator_id,
    evaluation_date,
    overall_notes,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, client_id, coordinator_id, evaluation_date, overall_notes, status, created_at, updated_at
`

type CreateClientEvaluationParams struct {
	ID             string               `json:"id"`
	ClientID       string               `json:"client_id"`
	CoordinatorID  string               `json:"coordinator_id"`
	EvaluationDate pgtype.Date          `json:"evaluation_date"`
	OverallNotes   *string              `json:"overall_notes"`
	Status         EvaluationStatusEnum `json:"status"`
}

func (q *Queries) CreateClientEvaluation(ctx context.Context, arg CreateClientEvaluationParams) (ClientEvaluation, error) {
	row := q.db.QueryRow(ctx, createClientEvaluation,
		arg.ID,
		arg.ClientID,
		arg.CoordinatorID,
		arg.EvaluationDate,
		arg.OverallNotes,
		arg.Status,
	)
	var i ClientEvaluation
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.CoordinatorID,
		&i.EvaluationDate,
		&i.OverallNotes,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createGoalProgressLog = `-- name: CreateGoalProgressLog :exec
INSERT INTO goal_progress_logs (
    id,
    evaluation_id,
    goal_id,
    status,
    progress_notes
) VALUES (
    $1, $2, $3, $4, $5
)
`

type CreateGoalProgressLogParams struct {
	ID            string             `json:"id"`
	EvaluationID  string             `json:"evaluation_id"`
	GoalID        string             `json:"goal_id"`
	Status        GoalProgressStatus `json:"status"`
	ProgressNotes *string            `json:"progress_notes"`
}

func (q *Queries) CreateGoalProgressLog(ctx context.Context, arg CreateGoalProgressLogParams) error {
	_, err := q.db.Exec(ctx, createGoalProgressLog,
		arg.ID,
		arg.EvaluationID,
		arg.GoalID,
		arg.Status,
		arg.ProgressNotes,
	)
	return err
}

const deleteDraftEvaluation = `-- name: DeleteDraftEvaluation :exec
DELETE FROM client_evaluations 
WHERE id = $1 AND status = 'draft'
`

func (q *Queries) DeleteDraftEvaluation(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteDraftEvaluation, id)
	return err
}

const deleteGoalProgressLogsByEvaluationId = `-- name: DeleteGoalProgressLogsByEvaluationId :exec
DELETE FROM goal_progress_logs 
WHERE evaluation_id = $1
`

func (q *Queries) DeleteGoalProgressLogsByEvaluationId(ctx context.Context, evaluationID string) error {
	_, err := q.db.Exec(ctx, deleteGoalProgressLogsByEvaluationId, evaluationID)
	return err
}

const getClientEvaluationHistory = `-- name: GetClientEvaluationHistory :many
SELECT 
    e.id as evaluation_id,
    e.evaluation_date,
    e.overall_notes,
    g.id as goal_id,
    g.title as goal_title,
    l.status,
    l.progress_notes,
    emp.first_name as coordinator_first_name,
    emp.last_name as coordinator_last_name
FROM client_evaluations e
JOIN goal_progress_logs l ON e.id = l.evaluation_id
JOIN client_goals g ON l.goal_id = g.id
JOIN employees emp ON e.coordinator_id = emp.id
WHERE e.client_id = $1
ORDER BY e.evaluation_date DESC, g.title ASC
`

type GetClientEvaluationHistoryRow struct {
	EvaluationID         string             `json:"evaluation_id"`
	EvaluationDate       pgtype.Date        `json:"evaluation_date"`
	OverallNotes         *string            `json:"overall_notes"`
	GoalID               string             `json:"goal_id"`
	GoalTitle            string             `json:"goal_title"`
	Status               GoalProgressStatus `json:"status"`
	ProgressNotes        *string            `json:"progress_notes"`
	CoordinatorFirstName string             `json:"coordinator_first_name"`
	CoordinatorLastName  string             `json:"coordinator_last_name"`
}

func (q *Queries) GetClientEvaluationHistory(ctx context.Context, clientID string) ([]GetClientEvaluationHistoryRow, error) {
	rows, err := q.db.Query(ctx, getClientEvaluationHistory, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClientEvaluationHistoryRow{}
	for rows.Next() {
		var i GetClientEvaluationHistoryRow
		if err := rows.Scan(
			&i.EvaluationID,
			&i.EvaluationDate,
			&i.OverallNotes,
			&i.GoalID,
			&i.GoalTitle,
			&i.Status,
			&i.ProgressNotes,
			&i.CoordinatorFirstName,
			&i.CoordinatorLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoordinatorDrafts = `-- name: GetCoordinatorDrafts :many
SELECT 
    e.id as evaluation_id,
    e.client_id,
    e.evaluation_date,
    e.created_at,
    e.updated_at,
    c.first_name as client_first_name,
    c.last_name as client_last_name,
    COUNT(l.id) as goals_count,
    COUNT(*) OVER() as total_count
FROM client_evaluations e
JOIN clients c ON e.client_id = c.id
LEFT JOIN goal_progress_logs l ON e.id = l.evaluation_id
WHERE e.coordinator_id = $1 AND e.status = 'draft'
GROUP BY e.id, e.client_id, e.evaluation_date, e.created_at, e.updated_at, c.first_name, c.last_name
ORDER BY e.updated_at DESC
LIMIT $2 OFFSET $3
`

type GetCoordinatorDraftsParams struct {
	CoordinatorID string `json:"coordinator_id"`
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
}

type GetCoordinatorDraftsRow struct {
	EvaluationID    string             `json:"evaluation_id"`
	ClientID        string             `json:"client_id"`
	EvaluationDate  pgtype.Date        `json:"evaluation_date"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	ClientFirstName string             `json:"client_first_name"`
	ClientLastName  string             `json:"client_last_name"`
	GoalsCount      int64              `json:"goals_count"`
	TotalCount      int64              `json:"total_count"`
}

func (q *Queries) GetCoordinatorDrafts(ctx context.Context, arg GetCoordinatorDraftsParams) ([]GetCoordinatorDraftsRow, error) {
	rows, err := q.db.Query(ctx, getCoordinatorDrafts, arg.CoordinatorID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCoordinatorDraftsRow{}
	for rows.Next() {
		var i GetCoordinatorDraftsRow
		if err := rows.Scan(
			&i.EvaluationID,
			&i.ClientID,
			&i.EvaluationDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClientFirstName,
			&i.ClientLastName,
			&i.GoalsCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCriticalEvaluations = `-- name: GetCriticalEvaluations :many
SELECT 
    c.id,
    c.first_name,
    c.last_name,
    c.next_evaluation_date,
    c.evaluation_interval_weeks,
    l.name as location_name,
    e.first_name as coordinator_first_name,
    e.last_name as coordinator_last_name,
    COALESCE((
        SELECT ce.id FROM client_evaluations ce 
        WHERE ce.client_id = c.id AND ce.status = 'draft'
        LIMIT 1
    ), '') as draft_id,
    COUNT(*) OVER() as total_count
FROM clients c
JOIN locations l ON c.assigned_location_id = l.id
JOIN employees e ON c.coordinator_id = e.id
WHERE c.status = 'in_care' 
  AND c.next_evaluation_date IS NOT NULL
  AND c.next_evaluation_date <= (CURRENT_DATE + INTERVAL '7 days')::date
ORDER BY c.next_evaluation_date ASC
LIMIT $1 OFFSET $2
`

type GetCriticalEvaluationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetCriticalEvaluationsRow struct {
	ID                      string      `json:"id"`
	FirstName               string      `json:"first_name"`
	LastName                string      `json:"last_name"`
	NextEvaluationDate      pgtype.Date `json:"next_evaluation_date"`
	EvaluationIntervalWeeks *int32      `json:"evaluation_interval_weeks"`
	LocationName            string      `json:"location_name"`
	CoordinatorFirstName    string      `json:"coordinator_first_name"`
	CoordinatorLastName     string      `json:"coordinator_last_name"`
	DraftID                 interface{} `json:"draft_id"`
	TotalCount              int64       `json:"total_count"`
}

func (q *Queries) GetCriticalEvaluations(ctx context.Context, arg GetCriticalEvaluationsParams) ([]GetCriticalEvaluationsRow, error) {
	rows, err := q.db.Query(ctx, getCriticalEvaluations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCriticalEvaluationsRow{}
	for rows.Next() {
		var i GetCriticalEvaluationsRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.NextEvaluationDate,
			&i.EvaluationIntervalWeeks,
			&i.LocationName,
			&i.CoordinatorFirstName,
			&i.CoordinatorLastName,
			&i.DraftID,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDraftByClientId = `-- name: GetDraftByClientId :one
SELECT id, client_id, coordinator_id, evaluation_date, overall_notes, status, created_at, updated_at FROM client_evaluations 
WHERE client_id = $1 AND status = 'draft'
LIMIT 1
`

func (q *Queries) GetDraftByClientId(ctx context.Context, clientID string) (ClientEvaluation, error) {
	row := q.db.QueryRow(ctx, getDraftByClientId, clientID)
	var i ClientEvaluation
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.CoordinatorID,
		&i.EvaluationDate,
		&i.OverallNotes,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDraftEvaluation = `-- name: GetDraftEvaluation :many
SELECT 
    e.id as evaluation_id,
    e.client_id,
    e.evaluation_date,
    e.overall_notes,
    e.created_at,
    e.updated_at,
    emp.first_name as coordinator_first_name,
    emp.last_name as coordinator_last_name,
    c.first_name as client_first_name,
    c.last_name as client_last_name,
    g.id as goal_id,
    g.title as goal_title,
    l.status,
    l.progress_notes
FROM client_evaluations e
JOIN employees emp ON e.coordinator_id = emp.id
JOIN clients c ON e.client_id = c.id
LEFT JOIN goal_progress_logs l ON e.id = l.evaluation_id
LEFT JOIN client_goals g ON l.goal_id = g.id
WHERE e.id = $1 AND e.status = 'draft'
ORDER BY g.title ASC
`

type GetDraftEvaluationRow struct {
	EvaluationID         string                 `json:"evaluation_id"`
	ClientID             string                 `json:"client_id"`
	EvaluationDate       pgtype.Date            `json:"evaluation_date"`
	OverallNotes         *string                `json:"overall_notes"`
	CreatedAt            pgtype.Timestamptz     `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz     `json:"updated_at"`
	CoordinatorFirstName string                 `json:"coordinator_first_name"`
	CoordinatorLastName  string                 `json:"coordinator_last_name"`
	ClientFirstName      string                 `json:"client_first_name"`
	ClientLastName       string                 `json:"client_last_name"`
	GoalID               *string                `json:"goal_id"`
	GoalTitle            *string                `json:"goal_title"`
	Status               NullGoalProgressStatus `json:"status"`
	ProgressNotes        *string                `json:"progress_notes"`
}

func (q *Queries) GetDraftEvaluation(ctx context.Context, id string) ([]GetDraftEvaluationRow, error) {
	rows, err := q.db.Query(ctx, getDraftEvaluation, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDraftEvaluationRow{}
	for rows.Next() {
		var i GetDraftEvaluationRow
		if err := rows.Scan(
			&i.EvaluationID,
			&i.ClientID,
			&i.EvaluationDate,
			&i.OverallNotes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CoordinatorFirstName,
			&i.CoordinatorLastName,
			&i.ClientFirstName,
			&i.ClientLastName,
			&i.GoalID,
			&i.GoalTitle,
			&i.Status,
			&i.ProgressNotes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvaluationById = `-- name: GetEvaluationById :one
SELECT id, client_id, coordinator_id, evaluation_date, overall_notes, status, created_at, updated_at FROM client_evaluations WHERE id = $1
`

func (q *Queries) GetEvaluationById(ctx context.Context, id string) (ClientEvaluation, error) {
	row := q.db.QueryRow(ctx, getEvaluationById, id)
	var i ClientEvaluation
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.CoordinatorID,
		&i.EvaluationDate,
		&i.OverallNotes,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEvaluationDetails = `-- name: GetEvaluationDetails :many
SELECT 
    e.id as evaluation_id,
    e.client_id,
    e.evaluation_date,
    e.overall_notes,
    e.status as evaluation_status,
    e.created_at,
    e.updated_at,
    emp.first_name as coordinator_first_name,
    emp.last_name as coordinator_last_name,
    c.first_name as client_first_name,
    c.last_name as client_last_name,
    g.id as goal_id,
    g.title as goal_title,
    l.status as progress_status,
    l.progress_notes
FROM client_evaluations e
JOIN employees emp ON e.coordinator_id = emp.id
JOIN clients c ON e.client_id = c.id
LEFT JOIN goal_progress_logs l ON e.id = l.evaluation_id
LEFT JOIN client_goals g ON l.goal_id = g.id
WHERE e.id = $1
ORDER BY g.title ASC
`

type GetEvaluationDetailsRow struct {
	EvaluationID         string                 `json:"evaluation_id"`
	ClientID             string                 `json:"client_id"`
	EvaluationDate       pgtype.Date            `json:"evaluation_date"`
	OverallNotes         *string                `json:"overall_notes"`
	EvaluationStatus     EvaluationStatusEnum   `json:"evaluation_status"`
	CreatedAt            pgtype.Timestamptz     `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz     `json:"updated_at"`
	CoordinatorFirstName string                 `json:"coordinator_first_name"`
	CoordinatorLastName  string                 `json:"coordinator_last_name"`
	ClientFirstName      string                 `json:"client_first_name"`
	ClientLastName       string                 `json:"client_last_name"`
	GoalID               *string                `json:"goal_id"`
	GoalTitle            *string                `json:"goal_title"`
	ProgressStatus       NullGoalProgressStatus `json:"progress_status"`
	ProgressNotes        *string                `json:"progress_notes"`
}

func (q *Queries) GetEvaluationDetails(ctx context.Context, id string) ([]GetEvaluationDetailsRow, error) {
	rows, err := q.db.Query(ctx, getEvaluationDetails, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEvaluationDetailsRow{}
	for rows.Next() {
		var i GetEvaluationDetailsRow
		if err := rows.Scan(
			&i.EvaluationID,
			&i.ClientID,
			&i.EvaluationDate,
			&i.OverallNotes,
			&i.EvaluationStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CoordinatorFirstName,
			&i.CoordinatorLastName,
			&i.ClientFirstName,
			&i.ClientLastName,
			&i.GoalID,
			&i.GoalTitle,
			&i.ProgressStatus,
			&i.ProgressNotes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastClientEvaluation = `-- name: GetLastClientEvaluation :many
SELECT 
    e.id as evaluation_id,
    e.evaluation_date,
    e.overall_notes,
    emp.first_name as coordinator_first_name,
    emp.last_name as coordinator_last_name,
    g.id as goal_id,
    g.title as goal_title,
    l.status,
    l.progress_notes
FROM client_evaluations e
JOIN goal_progress_logs l ON e.id = l.evaluation_id
JOIN client_goals g ON l.goal_id = g.id
JOIN employees emp ON e.coordinator_id = emp.id
WHERE e.client_id = $1 AND e.status = 'submitted'
ORDER BY e.evaluation_date DESC, g.title ASC
LIMIT (SELECT COUNT(*) FROM goal_progress_logs WHERE evaluation_id = (
    SELECT id FROM client_evaluations WHERE client_id = $1 AND status = 'submitted' ORDER BY evaluation_date DESC LIMIT 1
))
`

type GetLastClientEvaluationRow struct {
	EvaluationID         string             `json:"evaluation_id"`
	EvaluationDate       pgtype.Date        `json:"evaluation_date"`
	OverallNotes         *string            `json:"overall_notes"`
	CoordinatorFirstName string             `json:"coordinator_first_name"`
	CoordinatorLastName  string             `json:"coordinator_last_name"`
	GoalID               string             `json:"goal_id"`
	GoalTitle            string             `json:"goal_title"`
	Status               GoalProgressStatus `json:"status"`
	ProgressNotes        *string            `json:"progress_notes"`
}

func (q *Queries) GetLastClientEvaluation(ctx context.Context, clientID string) ([]GetLastClientEvaluationRow, error) {
	rows, err := q.db.Query(ctx, getLastClientEvaluation, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLastClientEvaluationRow{}
	for rows.Next() {
		var i GetLastClientEvaluationRow
		if err := rows.Scan(
			&i.EvaluationID,
			&i.EvaluationDate,
			&i.OverallNotes,
			&i.CoordinatorFirstName,
			&i.CoordinatorLastName,
			&i.GoalID,
			&i.GoalTitle,
			&i.Status,
			&i.ProgressNotes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentEvaluationsGlobal = `-- name: GetRecentEvaluationsGlobal :many
SELECT 
    e.id as evaluation_id,
    e.evaluation_date,
    e.client_id,
    c.first_name as client_first_name,
    c.last_name as client_last_name,
    emp.first_name as coordinator_first_name,
    emp.last_name as coordinator_last_name,
    (SELECT COUNT(*) FROM goal_progress_logs WHERE evaluation_id = e.id) as total_goals,
    (SELECT COUNT(*) FROM goal_progress_logs WHERE evaluation_id = e.id AND status = 'achieved') as goals_achieved,
    COUNT(*) OVER() as total_count
FROM client_evaluations e
JOIN clients c ON e.client_id = c.id
JOIN employees emp ON e.coordinator_id = emp.id
ORDER BY e.evaluation_date DESC
LIMIT $1 OFFSET $2
`

type GetRecentEvaluationsGlobalParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetRecentEvaluationsGlobalRow struct {
	EvaluationID         string      `json:"evaluation_id"`
	EvaluationDate       pgtype.Date `json:"evaluation_date"`
	ClientID             string      `json:"client_id"`
	ClientFirstName      string      `json:"client_first_name"`
	ClientLastName       string      `json:"client_last_name"`
	CoordinatorFirstName string      `json:"coordinator_first_name"`
	CoordinatorLastName  string      `json:"coordinator_last_name"`
	TotalGoals           int64       `json:"total_goals"`
	GoalsAchieved        int64       `json:"goals_achieved"`
	TotalCount           int64       `json:"total_count"`
}

func (q *Queries) GetRecentEvaluationsGlobal(ctx context.Context, arg GetRecentEvaluationsGlobalParams) ([]GetRecentEvaluationsGlobalRow, error) {
	rows, err := q.db.Query(ctx, getRecentEvaluationsGlobal, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentEvaluationsGlobalRow{}
	for rows.Next() {
		var i GetRecentEvaluationsGlobalRow
		if err := rows.Scan(
			&i.EvaluationID,
			&i.EvaluationDate,
			&i.ClientID,
			&i.ClientFirstName,
			&i.ClientLastName,
			&i.CoordinatorFirstName,
			&i.CoordinatorLastName,
			&i.TotalGoals,
			&i.GoalsAchieved,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScheduledEvaluations = `-- name: GetScheduledEvaluations :many
SELECT 
    c.id,
    c.first_name,
    c.last_name,
    c.next_evaluation_date,
    c.evaluation_interval_weeks,
    l.name as location_name,
    e.first_name as coordinator_first_name,
    e.last_name as coordinator_last_name,
    COALESCE((
        SELECT ce.id FROM client_evaluations ce 
        WHERE ce.client_id = c.id AND ce.status = 'draft'
        LIMIT 1
    ), '') as draft_id,
    COUNT(*) OVER() as total_count
FROM clients c
JOIN locations l ON c.assigned_location_id = l.id
JOIN employees e ON c.coordinator_id = e.id
WHERE c.status = 'in_care' 
  AND c.next_evaluation_date IS NOT NULL
  AND c.next_evaluation_date > (CURRENT_DATE + INTERVAL '7 days')::date
  AND c.next_evaluation_date <= (CURRENT_DATE + INTERVAL '30 days')::date
ORDER BY c.next_evaluation_date ASC
LIMIT $1 OFFSET $2
`

type GetScheduledEvaluationsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetScheduledEvaluationsRow struct {
	ID                      string      `json:"id"`
	FirstName               string      `json:"first_name"`
	LastName                string      `json:"last_name"`
	NextEvaluationDate      pgtype.Date `json:"next_evaluation_date"`
	EvaluationIntervalWeeks *int32      `json:"evaluation_interval_weeks"`
	LocationName            string      `json:"location_name"`
	CoordinatorFirstName    string      `json:"coordinator_first_name"`
	CoordinatorLastName     string      `json:"coordinator_last_name"`
	DraftID                 interface{} `json:"draft_id"`
	TotalCount              int64       `json:"total_count"`
}

func (q *Queries) GetScheduledEvaluations(ctx context.Context, arg GetScheduledEvaluationsParams) ([]GetScheduledEvaluationsRow, error) {
	rows, err := q.db.Query(ctx, getScheduledEvaluations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetScheduledEvaluationsRow{}
	for rows.Next() {
		var i GetScheduledEvaluationsRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.NextEvaluationDate,
			&i.EvaluationIntervalWeeks,
			&i.LocationName,
			&i.CoordinatorFirstName,
			&i.CoordinatorLastName,
			&i.DraftID,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const submitDraftEvaluation = `-- name: SubmitDraftEvaluation :one
UPDATE client_evaluations 
SET status = 'submitted', updated_at = NOW()
WHERE id = $1 AND status = 'draft'
RETURNING id, client_id, coordinator_id, evaluation_date, overall_notes, status, created_at, updated_at
`

func (q *Queries) SubmitDraftEvaluation(ctx context.Context, id string) (ClientEvaluation, error) {
	row := q.db.QueryRow(ctx, submitDraftEvaluation, id)
	var i ClientEvaluation
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.CoordinatorID,
		&i.EvaluationDate,
		&i.OverallNotes,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateClientEvaluation = `-- name: UpdateClientEvaluation :one
UPDATE client_evaluations 
SET evaluation_date = $2, overall_notes = $3, updated_at = NOW()
WHERE id = $1 AND status = 'submitted'
RETURNING id, client_id, coordinator_id, evaluation_date, overall_notes, status, created_at, updated_at
`

type UpdateClientEvaluationParams struct {
	ID             string      `json:"id"`
	EvaluationDate pgtype.Date `json:"evaluation_date"`
	OverallNotes   *string     `json:"overall_notes"`
}

func (q *Queries) UpdateClientEvaluation(ctx context.Context, arg UpdateClientEvaluationParams) (ClientEvaluation, error) {
	row := q.db.QueryRow(ctx, updateClientEvaluation, arg.ID, arg.EvaluationDate, arg.OverallNotes)
	var i ClientEvaluation
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.CoordinatorID,
		&i.EvaluationDate,
		&i.OverallNotes,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateClientNextEvaluationDate = `-- name: UpdateClientNextEvaluationDate :exec
UPDATE clients 
SET next_evaluation_date = $2, updated_at = NOW() 
WHERE id = $1
`

type UpdateClientNextEvaluationDateParams struct {
	ID                 string      `json:"id"`
	NextEvaluationDate pgtype.Date `json:"next_evaluation_date"`
}

func (q *Queries) UpdateClientNextEvaluationDate(ctx context.Context, arg UpdateClientNextEvaluationDateParams) error {
	_, err := q.db.Exec(ctx, updateClientNextEvaluationDate, arg.ID, arg.NextEvaluationDate)
	return err
}

const updateGoalProgressLog = `-- name: UpdateGoalProgressLog :exec
UPDATE goal_progress_logs 
SET status = $2, progress_notes = $3
WHERE evaluation_id = $1 AND goal_id = $4
`

type UpdateGoalProgressLogParams struct {
	EvaluationID  string             `json:"evaluation_id"`
	Status        GoalProgressStatus `json:"status"`
	ProgressNotes *string            `json:"progress_notes"`
	GoalID        string             `json:"goal_id"`
}

func (q *Queries) UpdateGoalProgressLog(ctx context.Context, arg UpdateGoalProgressLogParams) error {
	_, err := q.db.Exec(ctx, updateGoalProgressLog,
		arg.EvaluationID,
		arg.Status,
		arg.ProgressNotes,
		arg.GoalID,
	)
	return err
}
