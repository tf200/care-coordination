// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: intake_forms.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createIntakeForm = `-- name: CreateIntakeForm :exec
INSERT INTO intake_forms (
    id,
    registration_form_id,
    intake_date,
    intake_time,
    location_id,
    coordinator_id,
    family_situation,
    main_provider,
    limitations,
    focus_areas,
    goals,
    notes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
)
`

type CreateIntakeFormParams struct {
	ID                 string      `json:"id"`
	RegistrationFormID string      `json:"registration_form_id"`
	IntakeDate         pgtype.Date `json:"intake_date"`
	IntakeTime         pgtype.Time `json:"intake_time"`
	LocationID         string      `json:"location_id"`
	CoordinatorID      string      `json:"coordinator_id"`
	FamilySituation    *string     `json:"family_situation"`
	MainProvider       *string     `json:"main_provider"`
	Limitations        *string     `json:"limitations"`
	FocusAreas         *string     `json:"focus_areas"`
	Goals              *string     `json:"goals"`
	Notes              *string     `json:"notes"`
}

func (q *Queries) CreateIntakeForm(ctx context.Context, arg CreateIntakeFormParams) error {
	_, err := q.db.Exec(ctx, createIntakeForm,
		arg.ID,
		arg.RegistrationFormID,
		arg.IntakeDate,
		arg.IntakeTime,
		arg.LocationID,
		arg.CoordinatorID,
		arg.FamilySituation,
		arg.MainProvider,
		arg.Limitations,
		arg.FocusAreas,
		arg.Goals,
		arg.Notes,
	)
	return err
}

const getIntakeForm = `-- name: GetIntakeForm :one
SELECT id, registration_form_id, intake_date, intake_time, location_id, coordinator_id, family_situation, main_provider, limitations, focus_areas, goals, notes, created_at, updated_at FROM intake_forms WHERE id = $1
`

func (q *Queries) GetIntakeForm(ctx context.Context, id string) (IntakeForm, error) {
	row := q.db.QueryRow(ctx, getIntakeForm, id)
	var i IntakeForm
	err := row.Scan(
		&i.ID,
		&i.RegistrationFormID,
		&i.IntakeDate,
		&i.IntakeTime,
		&i.LocationID,
		&i.CoordinatorID,
		&i.FamilySituation,
		&i.MainProvider,
		&i.Limitations,
		&i.FocusAreas,
		&i.Goals,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listIntakeForms = `-- name: ListIntakeForms :many
SELECT
    i.id,
    i.registration_form_id,
    i.intake_date,
    i.intake_time,
    i.location_id,
    i.coordinator_id,
    i.main_provider,
    r.first_name,
    r.last_name,
    r.bsn,
    ro.name as org_name,
    l.name as location_name,
    e.first_name as coordinator_first_name,
    e.last_name as coordinator_last_name,
    COUNT(i.id) OVER () AS total_count
FROM intake_forms i
LEFT JOIN registration_forms r ON i.registration_form_id = r.id
LEFT JOIN referring_orgs ro ON r.reffering_org_id = ro.id
LEFT JOIN locations l ON i.location_id = l.id
LEFT JOIN employees e ON i.coordinator_id = e.id
WHERE
    (
        -- If search term is NULL or empty, ignore filters
        $3::text IS NULL OR $3::text = '' OR
        -- Search by client first name
        r.first_name ILIKE '%' || $3 || '%' OR
        -- Search by client last name
        r.last_name ILIKE '%' || $3 || '%' OR
        -- Search by org name
        ro.name ILIKE '%' || $3 || '%'
    )
ORDER BY i.intake_date DESC, i.intake_time DESC
LIMIT $1 OFFSET $2
`

type ListIntakeFormsParams struct {
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
	Column3 string `json:"column_3"`
}

type ListIntakeFormsRow struct {
	ID                   string      `json:"id"`
	RegistrationFormID   string      `json:"registration_form_id"`
	IntakeDate           pgtype.Date `json:"intake_date"`
	IntakeTime           pgtype.Time `json:"intake_time"`
	LocationID           string      `json:"location_id"`
	CoordinatorID        string      `json:"coordinator_id"`
	MainProvider         *string     `json:"main_provider"`
	FirstName            *string     `json:"first_name"`
	LastName             *string     `json:"last_name"`
	Bsn                  *string     `json:"bsn"`
	OrgName              *string     `json:"org_name"`
	LocationName         *string     `json:"location_name"`
	CoordinatorFirstName *string     `json:"coordinator_first_name"`
	CoordinatorLastName  *string     `json:"coordinator_last_name"`
	TotalCount           int64       `json:"total_count"`
}

func (q *Queries) ListIntakeForms(ctx context.Context, arg ListIntakeFormsParams) ([]ListIntakeFormsRow, error) {
	rows, err := q.db.Query(ctx, listIntakeForms, arg.Limit, arg.Offset, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListIntakeFormsRow{}
	for rows.Next() {
		var i ListIntakeFormsRow
		if err := rows.Scan(
			&i.ID,
			&i.RegistrationFormID,
			&i.IntakeDate,
			&i.IntakeTime,
			&i.LocationID,
			&i.CoordinatorID,
			&i.MainProvider,
			&i.FirstName,
			&i.LastName,
			&i.Bsn,
			&i.OrgName,
			&i.LocationName,
			&i.CoordinatorFirstName,
			&i.CoordinatorLastName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
