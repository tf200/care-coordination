// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: location_transfers.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLocationTransfer = `-- name: CreateLocationTransfer :one
INSERT INTO client_location_transfers (
    id,
    client_id,
    from_location_id,
    to_location_id,
    current_coordinator_id,
    new_coordinator_id,
    transfer_date,
    reason
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, client_id, from_location_id, to_location_id, current_coordinator_id, new_coordinator_id, transfer_date
`

type CreateLocationTransferParams struct {
	ID                   string           `json:"id"`
	ClientID             string           `json:"client_id"`
	FromLocationID       *string          `json:"from_location_id"`
	ToLocationID         string           `json:"to_location_id"`
	CurrentCoordinatorID string           `json:"current_coordinator_id"`
	NewCoordinatorID     string           `json:"new_coordinator_id"`
	TransferDate         pgtype.Timestamp `json:"transfer_date"`
	Reason               *string          `json:"reason"`
}

type CreateLocationTransferRow struct {
	ID                   string           `json:"id"`
	ClientID             string           `json:"client_id"`
	FromLocationID       *string          `json:"from_location_id"`
	ToLocationID         string           `json:"to_location_id"`
	CurrentCoordinatorID string           `json:"current_coordinator_id"`
	NewCoordinatorID     string           `json:"new_coordinator_id"`
	TransferDate         pgtype.Timestamp `json:"transfer_date"`
}

func (q *Queries) CreateLocationTransfer(ctx context.Context, arg CreateLocationTransferParams) (CreateLocationTransferRow, error) {
	row := q.db.QueryRow(ctx, createLocationTransfer,
		arg.ID,
		arg.ClientID,
		arg.FromLocationID,
		arg.ToLocationID,
		arg.CurrentCoordinatorID,
		arg.NewCoordinatorID,
		arg.TransferDate,
		arg.Reason,
	)
	var i CreateLocationTransferRow
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.FromLocationID,
		&i.ToLocationID,
		&i.CurrentCoordinatorID,
		&i.NewCoordinatorID,
		&i.TransferDate,
	)
	return i, err
}

const listLocationTransfers = `-- name: ListLocationTransfers :many
SELECT
    clt.id,
    clt.client_id,
    clt.from_location_id,
    clt.to_location_id,
    clt.current_coordinator_id,
    clt.new_coordinator_id,
    clt.transfer_date,
    clt.reason,
    c.first_name AS client_first_name,
    c.last_name AS client_last_name,
    l_from.name AS from_location_name,
    l_to.name AS to_location_name,
    e_current.first_name AS current_coordinator_first_name,
    e_current.last_name AS current_coordinator_last_name,
    e_new.first_name AS new_coordinator_first_name,
    e_new.last_name AS new_coordinator_last_name,
    COUNT(*) OVER() AS total_count
FROM client_location_transfers clt
JOIN clients c ON clt.client_id = c.id
LEFT JOIN locations l_from ON clt.from_location_id = l_from.id
LEFT JOIN locations l_to ON clt.to_location_id = l_to.id
LEFT JOIN employees e_current ON clt.current_coordinator_id = e_current.id
LEFT JOIN employees e_new ON clt.new_coordinator_id = e_new.id
WHERE
    ($3::text IS NULL OR
     c.first_name ILIKE '%' || $3 || '%' OR
     c.last_name ILIKE '%' || $3 || '%' OR
     CONCAT(c.first_name, ' ', c.last_name) ILIKE '%' || $3 || '%'
    )   
ORDER BY clt.transfer_date DESC
LIMIT $1 OFFSET $2
`

type ListLocationTransfersParams struct {
	Limit  int32   `json:"limit"`
	Offset int32   `json:"offset"`
	Search *string `json:"search"`
}

type ListLocationTransfersRow struct {
	ID                          string           `json:"id"`
	ClientID                    string           `json:"client_id"`
	FromLocationID              *string          `json:"from_location_id"`
	ToLocationID                string           `json:"to_location_id"`
	CurrentCoordinatorID        string           `json:"current_coordinator_id"`
	NewCoordinatorID            string           `json:"new_coordinator_id"`
	TransferDate                pgtype.Timestamp `json:"transfer_date"`
	Reason                      *string          `json:"reason"`
	ClientFirstName             string           `json:"client_first_name"`
	ClientLastName              string           `json:"client_last_name"`
	FromLocationName            *string          `json:"from_location_name"`
	ToLocationName              *string          `json:"to_location_name"`
	CurrentCoordinatorFirstName *string          `json:"current_coordinator_first_name"`
	CurrentCoordinatorLastName  *string          `json:"current_coordinator_last_name"`
	NewCoordinatorFirstName     *string          `json:"new_coordinator_first_name"`
	NewCoordinatorLastName      *string          `json:"new_coordinator_last_name"`
	TotalCount                  int64            `json:"total_count"`
}

func (q *Queries) ListLocationTransfers(ctx context.Context, arg ListLocationTransfersParams) ([]ListLocationTransfersRow, error) {
	rows, err := q.db.Query(ctx, listLocationTransfers, arg.Limit, arg.Offset, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLocationTransfersRow{}
	for rows.Next() {
		var i ListLocationTransfersRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.FromLocationID,
			&i.ToLocationID,
			&i.CurrentCoordinatorID,
			&i.NewCoordinatorID,
			&i.TransferDate,
			&i.Reason,
			&i.ClientFirstName,
			&i.ClientLastName,
			&i.FromLocationName,
			&i.ToLocationName,
			&i.CurrentCoordinatorFirstName,
			&i.CurrentCoordinatorLastName,
			&i.NewCoordinatorFirstName,
			&i.NewCoordinatorLastName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
