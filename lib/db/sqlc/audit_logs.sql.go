// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: audit_logs.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAuditLogs = `-- name: CountAuditLogs :one
SELECT COUNT(*) as total FROM audit_logs
`

func (q *Queries) CountAuditLogs(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAuditLogs)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createAuditLog = `-- name: CreateAuditLog :exec
INSERT INTO audit_logs (
    id, user_id, employee_id, client_id, action, resource_type, resource_id,
    old_value, new_value, ip_address, user_agent, request_id, status, failure_reason,
    prev_hash, current_hash
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
)
`

type CreateAuditLogParams struct {
	ID            string          `json:"id"`
	UserID        *string         `json:"user_id"`
	EmployeeID    *string         `json:"employee_id"`
	ClientID      *string         `json:"client_id"`
	Action        AuditActionEnum `json:"action"`
	ResourceType  string          `json:"resource_type"`
	ResourceID    *string         `json:"resource_id"`
	OldValue      []byte          `json:"old_value"`
	NewValue      []byte          `json:"new_value"`
	IpAddress     *string         `json:"ip_address"`
	UserAgent     *string         `json:"user_agent"`
	RequestID     *string         `json:"request_id"`
	Status        AuditStatusEnum `json:"status"`
	FailureReason *string         `json:"failure_reason"`
	PrevHash      string          `json:"prev_hash"`
	CurrentHash   string          `json:"current_hash"`
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) error {
	_, err := q.db.Exec(ctx, createAuditLog,
		arg.ID,
		arg.UserID,
		arg.EmployeeID,
		arg.ClientID,
		arg.Action,
		arg.ResourceType,
		arg.ResourceID,
		arg.OldValue,
		arg.NewValue,
		arg.IpAddress,
		arg.UserAgent,
		arg.RequestID,
		arg.Status,
		arg.FailureReason,
		arg.PrevHash,
		arg.CurrentHash,
	)
	return err
}

const getAuditLogByID = `-- name: GetAuditLogByID :one
SELECT 
    al.id, al.sequence_number, al.user_id, al.employee_id, al.client_id, al.action, al.resource_type, al.resource_id, al.old_value, al.new_value, al.ip_address, al.user_agent, al.request_id, al.status, al.failure_reason, al.prev_hash, al.current_hash, al.created_at,
    u.email as user_email,
    COALESCE(e.first_name || ' ' || e.last_name, '') as employee_name,
    COALESCE(c.first_name || ' ' || c.last_name, '') as client_name
FROM audit_logs al
LEFT JOIN users u ON al.user_id = u.id
LEFT JOIN employees e ON al.employee_id = e.id
LEFT JOIN clients c ON al.client_id = c.id
WHERE al.id = $1
`

type GetAuditLogByIDRow struct {
	ID             string             `json:"id"`
	SequenceNumber int64              `json:"sequence_number"`
	UserID         *string            `json:"user_id"`
	EmployeeID     *string            `json:"employee_id"`
	ClientID       *string            `json:"client_id"`
	Action         AuditActionEnum    `json:"action"`
	ResourceType   string             `json:"resource_type"`
	ResourceID     *string            `json:"resource_id"`
	OldValue       []byte             `json:"old_value"`
	NewValue       []byte             `json:"new_value"`
	IpAddress      *string            `json:"ip_address"`
	UserAgent      *string            `json:"user_agent"`
	RequestID      *string            `json:"request_id"`
	Status         AuditStatusEnum    `json:"status"`
	FailureReason  *string            `json:"failure_reason"`
	PrevHash       string             `json:"prev_hash"`
	CurrentHash    string             `json:"current_hash"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UserEmail      *string            `json:"user_email"`
	EmployeeName   interface{}        `json:"employee_name"`
	ClientName     interface{}        `json:"client_name"`
}

func (q *Queries) GetAuditLogByID(ctx context.Context, id string) (GetAuditLogByIDRow, error) {
	row := q.db.QueryRow(ctx, getAuditLogByID, id)
	var i GetAuditLogByIDRow
	err := row.Scan(
		&i.ID,
		&i.SequenceNumber,
		&i.UserID,
		&i.EmployeeID,
		&i.ClientID,
		&i.Action,
		&i.ResourceType,
		&i.ResourceID,
		&i.OldValue,
		&i.NewValue,
		&i.IpAddress,
		&i.UserAgent,
		&i.RequestID,
		&i.Status,
		&i.FailureReason,
		&i.PrevHash,
		&i.CurrentHash,
		&i.CreatedAt,
		&i.UserEmail,
		&i.EmployeeName,
		&i.ClientName,
	)
	return i, err
}

const getAuditLogBySequence = `-- name: GetAuditLogBySequence :one
SELECT id, sequence_number, user_id, employee_id, client_id, action, resource_type, resource_id, old_value, new_value, ip_address, user_agent, request_id, status, failure_reason, prev_hash, current_hash, created_at FROM audit_logs WHERE sequence_number = $1
`

func (q *Queries) GetAuditLogBySequence(ctx context.Context, sequenceNumber int64) (AuditLog, error) {
	row := q.db.QueryRow(ctx, getAuditLogBySequence, sequenceNumber)
	var i AuditLog
	err := row.Scan(
		&i.ID,
		&i.SequenceNumber,
		&i.UserID,
		&i.EmployeeID,
		&i.ClientID,
		&i.Action,
		&i.ResourceType,
		&i.ResourceID,
		&i.OldValue,
		&i.NewValue,
		&i.IpAddress,
		&i.UserAgent,
		&i.RequestID,
		&i.Status,
		&i.FailureReason,
		&i.PrevHash,
		&i.CurrentHash,
		&i.CreatedAt,
	)
	return i, err
}

const getAuditLogStats = `-- name: GetAuditLogStats :one
SELECT 
    COUNT(*) as total_logs,
    COUNT(*) FILTER (WHERE action = 'read') as read_count,
    COUNT(*) FILTER (WHERE action = 'create') as create_count,
    COUNT(*) FILTER (WHERE action = 'update') as update_count,
    COUNT(*) FILTER (WHERE action = 'delete') as delete_count,
    COUNT(*) FILTER (WHERE status = 'failure') as failure_count
FROM audit_logs
WHERE created_at >= NOW() - INTERVAL '24 hours'
`

type GetAuditLogStatsRow struct {
	TotalLogs    int64 `json:"total_logs"`
	ReadCount    int64 `json:"read_count"`
	CreateCount  int64 `json:"create_count"`
	UpdateCount  int64 `json:"update_count"`
	DeleteCount  int64 `json:"delete_count"`
	FailureCount int64 `json:"failure_count"`
}

func (q *Queries) GetAuditLogStats(ctx context.Context) (GetAuditLogStatsRow, error) {
	row := q.db.QueryRow(ctx, getAuditLogStats)
	var i GetAuditLogStatsRow
	err := row.Scan(
		&i.TotalLogs,
		&i.ReadCount,
		&i.CreateCount,
		&i.UpdateCount,
		&i.DeleteCount,
		&i.FailureCount,
	)
	return i, err
}

const getAuditLogsByResource = `-- name: GetAuditLogsByResource :many
SELECT id, sequence_number, user_id, employee_id, client_id, action, resource_type, resource_id, old_value, new_value, ip_address, user_agent, request_id, status, failure_reason, prev_hash, current_hash, created_at FROM audit_logs
WHERE resource_type = $1 AND resource_id = $2
ORDER BY sequence_number DESC
LIMIT $3
`

type GetAuditLogsByResourceParams struct {
	ResourceType string  `json:"resource_type"`
	ResourceID   *string `json:"resource_id"`
	Limit        int32   `json:"limit"`
}

func (q *Queries) GetAuditLogsByResource(ctx context.Context, arg GetAuditLogsByResourceParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, getAuditLogsByResource, arg.ResourceType, arg.ResourceID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.SequenceNumber,
			&i.UserID,
			&i.EmployeeID,
			&i.ClientID,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.OldValue,
			&i.NewValue,
			&i.IpAddress,
			&i.UserAgent,
			&i.RequestID,
			&i.Status,
			&i.FailureReason,
			&i.PrevHash,
			&i.CurrentHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogsByUser = `-- name: GetAuditLogsByUser :many
SELECT id, sequence_number, user_id, employee_id, client_id, action, resource_type, resource_id, old_value, new_value, ip_address, user_agent, request_id, status, failure_reason, prev_hash, current_hash, created_at FROM audit_logs
WHERE user_id = $1
ORDER BY sequence_number DESC
LIMIT $2 OFFSET $3
`

type GetAuditLogsByUserParams struct {
	UserID *string `json:"user_id"`
	Limit  int32   `json:"limit"`
	Offset int32   `json:"offset"`
}

func (q *Queries) GetAuditLogsByUser(ctx context.Context, arg GetAuditLogsByUserParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, getAuditLogsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.SequenceNumber,
			&i.UserID,
			&i.EmployeeID,
			&i.ClientID,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.OldValue,
			&i.NewValue,
			&i.IpAddress,
			&i.UserAgent,
			&i.RequestID,
			&i.Status,
			&i.FailureReason,
			&i.PrevHash,
			&i.CurrentHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogsForVerification = `-- name: GetAuditLogsForVerification :many
SELECT id, sequence_number, user_id, employee_id, action, resource_type, resource_id,
       old_value, new_value, ip_address, user_agent, request_id, status, failure_reason,
       prev_hash, current_hash, created_at
FROM audit_logs
WHERE sequence_number >= $1 AND sequence_number <= $2
ORDER BY sequence_number ASC
`

type GetAuditLogsForVerificationParams struct {
	SequenceNumber   int64 `json:"sequence_number"`
	SequenceNumber_2 int64 `json:"sequence_number_2"`
}

type GetAuditLogsForVerificationRow struct {
	ID             string             `json:"id"`
	SequenceNumber int64              `json:"sequence_number"`
	UserID         *string            `json:"user_id"`
	EmployeeID     *string            `json:"employee_id"`
	Action         AuditActionEnum    `json:"action"`
	ResourceType   string             `json:"resource_type"`
	ResourceID     *string            `json:"resource_id"`
	OldValue       []byte             `json:"old_value"`
	NewValue       []byte             `json:"new_value"`
	IpAddress      *string            `json:"ip_address"`
	UserAgent      *string            `json:"user_agent"`
	RequestID      *string            `json:"request_id"`
	Status         AuditStatusEnum    `json:"status"`
	FailureReason  *string            `json:"failure_reason"`
	PrevHash       string             `json:"prev_hash"`
	CurrentHash    string             `json:"current_hash"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
}

// Get audit logs in sequence order for hash chain verification
func (q *Queries) GetAuditLogsForVerification(ctx context.Context, arg GetAuditLogsForVerificationParams) ([]GetAuditLogsForVerificationRow, error) {
	rows, err := q.db.Query(ctx, getAuditLogsForVerification, arg.SequenceNumber, arg.SequenceNumber_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAuditLogsForVerificationRow{}
	for rows.Next() {
		var i GetAuditLogsForVerificationRow
		if err := rows.Scan(
			&i.ID,
			&i.SequenceNumber,
			&i.UserID,
			&i.EmployeeID,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.OldValue,
			&i.NewValue,
			&i.IpAddress,
			&i.UserAgent,
			&i.RequestID,
			&i.Status,
			&i.FailureReason,
			&i.PrevHash,
			&i.CurrentHash,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestAuditLog = `-- name: GetLatestAuditLog :one
SELECT id, current_hash, sequence_number 
FROM audit_logs 
ORDER BY sequence_number DESC 
LIMIT 1
`

type GetLatestAuditLogRow struct {
	ID             string `json:"id"`
	CurrentHash    string `json:"current_hash"`
	SequenceNumber int64  `json:"sequence_number"`
}

// Get the most recent audit log entry to retrieve its hash for the chain
func (q *Queries) GetLatestAuditLog(ctx context.Context) (GetLatestAuditLogRow, error) {
	row := q.db.QueryRow(ctx, getLatestAuditLog)
	var i GetLatestAuditLogRow
	err := row.Scan(&i.ID, &i.CurrentHash, &i.SequenceNumber)
	return i, err
}

const listAuditLogs = `-- name: ListAuditLogs :many
SELECT 
    al.id, al.sequence_number, al.user_id, al.employee_id, al.client_id, al.action, al.resource_type, al.resource_id, al.old_value, al.new_value, al.ip_address, al.user_agent, al.request_id, al.status, al.failure_reason, al.prev_hash, al.current_hash, al.created_at,
    u.email as user_email,
    COALESCE(e.first_name || ' ' || e.last_name, '') as employee_name,
    COALESCE(c.first_name || ' ' || c.last_name, '') as client_name,
    COUNT(*) OVER() as total_count
FROM audit_logs al
LEFT JOIN users u ON al.user_id = u.id
LEFT JOIN employees e ON al.employee_id = e.id
LEFT JOIN clients c ON al.client_id = c.id
WHERE 
    ($3::TEXT IS NULL OR al.user_id = $3)
    AND ($4::TEXT IS NULL OR al.client_id = $4)
    AND ($5::TEXT IS NULL OR al.resource_type = $5)
    AND ($6::TEXT IS NULL OR al.resource_id = $6)
    AND ($7::audit_action_enum IS NULL OR al.action = $7)
    AND ($8::TIMESTAMP IS NULL OR al.created_at >= $8)
    AND ($9::TIMESTAMP IS NULL OR al.created_at <= $9)
ORDER BY al.sequence_number DESC
LIMIT $1 OFFSET $2
`

type ListAuditLogsParams struct {
	Limit        int32               `json:"limit"`
	Offset       int32               `json:"offset"`
	UserID       *string             `json:"user_id"`
	ClientID     *string             `json:"client_id"`
	ResourceType *string             `json:"resource_type"`
	ResourceID   *string             `json:"resource_id"`
	Action       NullAuditActionEnum `json:"action"`
	StartDate    pgtype.Timestamp    `json:"start_date"`
	EndDate      pgtype.Timestamp    `json:"end_date"`
}

type ListAuditLogsRow struct {
	ID             string             `json:"id"`
	SequenceNumber int64              `json:"sequence_number"`
	UserID         *string            `json:"user_id"`
	EmployeeID     *string            `json:"employee_id"`
	ClientID       *string            `json:"client_id"`
	Action         AuditActionEnum    `json:"action"`
	ResourceType   string             `json:"resource_type"`
	ResourceID     *string            `json:"resource_id"`
	OldValue       []byte             `json:"old_value"`
	NewValue       []byte             `json:"new_value"`
	IpAddress      *string            `json:"ip_address"`
	UserAgent      *string            `json:"user_agent"`
	RequestID      *string            `json:"request_id"`
	Status         AuditStatusEnum    `json:"status"`
	FailureReason  *string            `json:"failure_reason"`
	PrevHash       string             `json:"prev_hash"`
	CurrentHash    string             `json:"current_hash"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UserEmail      *string            `json:"user_email"`
	EmployeeName   interface{}        `json:"employee_name"`
	ClientName     interface{}        `json:"client_name"`
	TotalCount     int64              `json:"total_count"`
}

func (q *Queries) ListAuditLogs(ctx context.Context, arg ListAuditLogsParams) ([]ListAuditLogsRow, error) {
	rows, err := q.db.Query(ctx, listAuditLogs,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.ClientID,
		arg.ResourceType,
		arg.ResourceID,
		arg.Action,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAuditLogsRow{}
	for rows.Next() {
		var i ListAuditLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.SequenceNumber,
			&i.UserID,
			&i.EmployeeID,
			&i.ClientID,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.OldValue,
			&i.NewValue,
			&i.IpAddress,
			&i.UserAgent,
			&i.RequestID,
			&i.Status,
			&i.FailureReason,
			&i.PrevHash,
			&i.CurrentHash,
			&i.CreatedAt,
			&i.UserEmail,
			&i.EmployeeName,
			&i.ClientName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
