// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: incidents.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createIncident = `-- name: CreateIncident :exec
INSERT INTO incidents (
    client_id,
    incident_date,
    incident_time,
    incident_type,
    incident_severity,
    location_id,
    coordinator_id,
    incident_description,
    action_taken,
    other_parties,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
`

type CreateIncidentParams struct {
	ClientID            string               `json:"client_id"`
	IncidentDate        pgtype.Date          `json:"incident_date"`
	IncidentTime        pgtype.Time          `json:"incident_time"`
	IncidentType        IncidentTypeEnum     `json:"incident_type"`
	IncidentSeverity    IncidentSeverityEnum `json:"incident_severity"`
	LocationID          string               `json:"location_id"`
	CoordinatorID       string               `json:"coordinator_id"`
	IncidentDescription string               `json:"incident_description"`
	ActionTaken         string               `json:"action_taken"`
	OtherParties        *string              `json:"other_parties"`
	Status              IncidentStatusEnum   `json:"status"`
}

func (q *Queries) CreateIncident(ctx context.Context, arg CreateIncidentParams) error {
	_, err := q.db.Exec(ctx, createIncident,
		arg.ClientID,
		arg.IncidentDate,
		arg.IncidentTime,
		arg.IncidentType,
		arg.IncidentSeverity,
		arg.LocationID,
		arg.CoordinatorID,
		arg.IncidentDescription,
		arg.ActionTaken,
		arg.OtherParties,
		arg.Status,
	)
	return err
}

const listIncidents = `-- name: ListIncidents :many
SELECT i.id, i.client_id, i.incident_date, i.incident_time, i.incident_type, i.incident_severity, i.location_id, i.coordinator_id, i.incident_description, i.action_taken, i.other_parties, i.status, i.created_at, i.updated_at,
       c.first_name AS client_first_name,
       c.last_name AS client_last_name,
       l.name AS location_name,
       e.first_name AS coordinator_first_name,
       e.last_name AS coordinator_last_name,
       COUNT(*) OVER() as total_count
FROM incidents i
JOIN clients c ON i.client_id = c.id
JOIN locations l ON i.location_id = l.id
JOIN employees e ON i.coordinator_id = e.id
WHERE
(
  $3::text IS NULL OR
  c.first_name ILIKE '%' || $3::text || '%' OR
  c.last_name ILIKE '%' || $3::text || '%' OR
  CONCAT(c.first_name, ' ', c.last_name) ILIKE '%' || $3::text || '%'
)
ORDER BY i.incident_date DESC
LIMIT $1 OFFSET $2
`

type ListIncidentsParams struct {
	Limit  int32   `json:"limit"`
	Offset int32   `json:"offset"`
	Search *string `json:"search"`
}

type ListIncidentsRow struct {
	ID                   string               `json:"id"`
	ClientID             string               `json:"client_id"`
	IncidentDate         pgtype.Date          `json:"incident_date"`
	IncidentTime         pgtype.Time          `json:"incident_time"`
	IncidentType         IncidentTypeEnum     `json:"incident_type"`
	IncidentSeverity     IncidentSeverityEnum `json:"incident_severity"`
	LocationID           string               `json:"location_id"`
	CoordinatorID        string               `json:"coordinator_id"`
	IncidentDescription  string               `json:"incident_description"`
	ActionTaken          string               `json:"action_taken"`
	OtherParties         *string              `json:"other_parties"`
	Status               IncidentStatusEnum   `json:"status"`
	CreatedAt            pgtype.Timestamp     `json:"created_at"`
	UpdatedAt            pgtype.Timestamp     `json:"updated_at"`
	ClientFirstName      string               `json:"client_first_name"`
	ClientLastName       string               `json:"client_last_name"`
	LocationName         string               `json:"location_name"`
	CoordinatorFirstName string               `json:"coordinator_first_name"`
	CoordinatorLastName  string               `json:"coordinator_last_name"`
	TotalCount           int64                `json:"total_count"`
}

func (q *Queries) ListIncidents(ctx context.Context, arg ListIncidentsParams) ([]ListIncidentsRow, error) {
	rows, err := q.db.Query(ctx, listIncidents, arg.Limit, arg.Offset, arg.Search)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListIncidentsRow{}
	for rows.Next() {
		var i ListIncidentsRow
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.IncidentDate,
			&i.IncidentTime,
			&i.IncidentType,
			&i.IncidentSeverity,
			&i.LocationID,
			&i.CoordinatorID,
			&i.IncidentDescription,
			&i.ActionTaken,
			&i.OtherParties,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClientFirstName,
			&i.ClientLastName,
			&i.LocationName,
			&i.CoordinatorFirstName,
			&i.CoordinatorLastName,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
